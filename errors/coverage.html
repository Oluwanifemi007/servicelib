
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>errors: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/abitofhelp/servicelib/errors/errors.go (90.9%)</option>
				
				<option value="file1">github.com/abitofhelp/servicelib/errors/interfaces.go (82.4%)</option>
				
				<option value="file2">github.com/abitofhelp/servicelib/errors/mocks/mock_interfaces.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package errors provides a comprehensive error handling system for the application.
// It includes error codes, HTTP status mapping, contextual information, and utilities
// for creating, wrapping, and serializing errors.
package errors

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "path/filepath"
        "runtime"
        "strings"
)

// ErrorCode represents a unique error code for categorizing errors.
// These codes are used for error identification, logging, and mapping to HTTP status codes.
type ErrorCode string

// Standard error codes define all possible error categories in the application.
const (
        // NotFoundCode is used when a resource is not found.
        // Maps to HTTP 404 Not Found.
        NotFoundCode ErrorCode = "NOT_FOUND"

        // InvalidInputCode is used when input validation fails.
        // Maps to HTTP 400 Bad Request.
        InvalidInputCode ErrorCode = "INVALID_INPUT"

        // DatabaseErrorCode is used for database operation failures.
        // Maps to HTTP 500 Internal Server Error.
        DatabaseErrorCode ErrorCode = "DATABASE_ERROR"

        // InternalErrorCode is used for internal server errors.
        // Maps to HTTP 500 Internal Server Error.
        InternalErrorCode ErrorCode = "INTERNAL_ERROR"

        // TimeoutCode is used when an operation times out.
        // Maps to HTTP 504 Gateway Timeout.
        TimeoutCode ErrorCode = "TIMEOUT"

        // CanceledCode is used when an operation is canceled.
        // Maps to HTTP 408 Request Timeout.
        CanceledCode ErrorCode = "CANCELED"

        // AlreadyExistsCode is used when a resource already exists.
        // Maps to HTTP 409 Conflict.
        AlreadyExistsCode ErrorCode = "ALREADY_EXISTS"

        // UnauthorizedCode is used for authentication failures.
        // Maps to HTTP 401 Unauthorized.
        UnauthorizedCode ErrorCode = "UNAUTHORIZED"

        // ForbiddenCode is used for authorization failures.
        // Maps to HTTP 403 Forbidden.
        ForbiddenCode ErrorCode = "FORBIDDEN"

        // ValidationErrorCode is used for domain validation errors.
        // Maps to HTTP 400 Bad Request.
        ValidationErrorCode ErrorCode = "VALIDATION_ERROR"

        // BusinessRuleViolationCode is used when a business rule is violated.
        // Maps to HTTP 422 Unprocessable Entity.
        BusinessRuleViolationCode ErrorCode = "BUSINESS_RULE_VIOLATION"

        // ExternalServiceErrorCode is used when an external service call fails.
        // Maps to HTTP 502 Bad Gateway.
        ExternalServiceErrorCode ErrorCode = "EXTERNAL_SERVICE_ERROR"

        // NetworkErrorCode is used for network-related errors.
        // Maps to HTTP 503 Service Unavailable.
        NetworkErrorCode ErrorCode = "NETWORK_ERROR"

        // ConfigurationErrorCode is used for configuration errors.
        // Maps to HTTP 500 Internal Server Error.
        ConfigurationErrorCode ErrorCode = "CONFIGURATION_ERROR"

        // ResourceExhaustedCode is used when a resource limit is reached.
        // Maps to HTTP 429 Too Many Requests.
        ResourceExhaustedCode ErrorCode = "RESOURCE_EXHAUSTED"

        // DataCorruptionCode is used when data is corrupted.
        // Maps to HTTP 500 Internal Server Error.
        DataCorruptionCode ErrorCode = "DATA_CORRUPTION"

        // ConcurrencyErrorCode is used for concurrency-related errors.
        // Maps to HTTP 409 Conflict.
        ConcurrencyErrorCode ErrorCode = "CONCURRENCY_ERROR"
)

// Standard errors that can be used throughout the application
var (
        // ErrNotFound is returned when a requested resource is not found
        ErrNotFound = errors.New("resource not found")

        // ErrAlreadyExists is returned when a resource already exists
        ErrAlreadyExists = errors.New("resource already exists")

        // ErrInvalidInput is returned when the input to a function is invalid
        ErrInvalidInput = errors.New("invalid input")

        // ErrInternal is returned when an internal error occurs
        ErrInternal = errors.New("internal error")

        // ErrUnauthorized is returned when a user is not authorized to perform an action
        ErrUnauthorized = errors.New("unauthorized")

        // ErrForbidden is returned when a user is forbidden from performing an action
        ErrForbidden = errors.New("forbidden")

        // ErrTimeout is returned when an operation times out
        ErrTimeout = errors.New("operation timed out")

        // ErrCancelled is returned when an operation is cancelled
        ErrCancelled = errors.New("operation cancelled")

        // ErrConflict is returned when there is a conflict with the current state
        ErrConflict = errors.New("conflict with current state")
)

// ErrorContext holds additional context for an error.
// It includes information about the operation that failed, the source location,
// and any additional details that might be useful for debugging or error reporting.
type ErrorContext struct {
        // Operation is the name of the operation that failed
        Operation string `json:"operation,omitempty"`

        // Source is the file and line where the error occurred
        Source string `json:"source,omitempty"`

        // Line is the line number where the error occurred
        Line int `json:"line,omitempty"`

        // Code is the error code
        Code ErrorCode `json:"code,omitempty"`

        // HTTPStatus is the HTTP status code to return for this error
        HTTPStatus int `json:"http_status,omitempty"`

        // Details contains additional information about the error
        Details map[string]interface{} `json:"details,omitempty"`
}

// ContextualError is an error with additional context.
// It wraps another error and adds contextual information like operation name,
// error code, HTTP status, and source location.
type ContextualError struct {
        // Original is the original error that was wrapped
        Original error

        // Context contains additional information about the error
        Context ErrorContext
}

// Error returns the error message with contextual information.
func (e *ContextualError) Error() string <span class="cov8" title="1">{
        var builder strings.Builder

        // Add operation if available
        if e.Context.Operation != "" </span><span class="cov8" title="1">{
                builder.WriteString(fmt.Sprintf("operation %s: ", e.Context.Operation))
        }</span>

        // Add original error message
        <span class="cov8" title="1">if e.Original != nil </span><span class="cov8" title="1">{
                builder.WriteString(e.Original.Error())
        }</span> else<span class="cov0" title="0"> {
                builder.WriteString("an error occurred")
        }</span>

        // Add source location if available
        <span class="cov8" title="1">if e.Context.Source != "" </span><span class="cov8" title="1">{
                builder.WriteString(fmt.Sprintf(" (source: %s", e.Context.Source))
                if e.Context.Line &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf(":%d", e.Context.Line))
                }</span>
                <span class="cov8" title="1">builder.WriteString(")")</span>
        }

        <span class="cov8" title="1">return builder.String()</span>
}

// Unwrap returns the original error.
func (e *ContextualError) Unwrap() error <span class="cov8" title="1">{
        return e.Original
}</span>

// Code returns the error code.
func (e *ContextualError) Code() ErrorCode <span class="cov8" title="1">{
        return e.Context.Code
}</span>

// HTTPStatus returns the HTTP status code.
func (e *ContextualError) HTTPStatus() int <span class="cov8" title="1">{
        return e.Context.HTTPStatus
}</span>

// MarshalJSON implements the json.Marshaler interface.
func (e *ContextualError) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(struct {
                Message string       `json:"message"`
                Context ErrorContext `json:"context,omitempty"`
        }{
                Message: e.Error(),
                Context: e.Context,
        })
}</span>

// getCallerInfo returns the file name and line number of the caller.
func getCallerInfo(skip int) (string, int) <span class="cov8" title="1">{
        _, file, line, ok := runtime.Caller(skip + 1)
        if !ok </span><span class="cov0" title="0">{
                return "", 0
        }</span>
        <span class="cov8" title="1">return filepath.Base(file), line</span>
}

// withContext wraps an error with contextual information.
// It adds operation name, error code, HTTP status, and source location to the error.
// If the error is already a ContextualError, it updates the context with the new information.
func withContext(err error, operation string, code ErrorCode, httpStatus int, details map[string]interface{}) error <span class="cov8" title="1">{
        // Get caller information
        source, line := getCallerInfo(2)

        // If the error is already a ContextualError, update its context
        var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov8" title="1">{
                // Only update operation if it's not already set
                if operation != "" &amp;&amp; contextualErr.Context.Operation == "" </span><span class="cov0" title="0">{
                        contextualErr.Context.Operation = operation
                }</span>

                // Only update code if it's not already set
                <span class="cov8" title="1">if code != "" &amp;&amp; contextualErr.Context.Code == "" </span><span class="cov0" title="0">{
                        contextualErr.Context.Code = code
                }</span>

                // Only update HTTP status if it's not already set
                <span class="cov8" title="1">if httpStatus != 0 &amp;&amp; contextualErr.Context.HTTPStatus == 0 </span><span class="cov0" title="0">{
                        contextualErr.Context.HTTPStatus = httpStatus
                }</span>

                // Merge details if provided
                <span class="cov8" title="1">if details != nil </span><span class="cov8" title="1">{
                        if contextualErr.Context.Details == nil </span><span class="cov0" title="0">{
                                contextualErr.Context.Details = make(map[string]interface{})
                        }</span>
                        <span class="cov8" title="1">for k, v := range details </span><span class="cov8" title="1">{
                                contextualErr.Context.Details[k] = v
                        }</span>
                }

                <span class="cov8" title="1">return contextualErr</span>
        }

        // Create a new ContextualError
        <span class="cov8" title="1">return &amp;ContextualError{
                Original: err,
                Context: ErrorContext{
                        Operation:  operation,
                        Source:     source,
                        Line:       line,
                        Code:       code,
                        HTTPStatus: httpStatus,
                        Details:    details,
                },
        }</span>
}

// AppError is a generic error type that can be used for different error categories
type AppError[T ~string] struct {
        Err     error
        Message string
        Code    string
        Type    T
}

func (e *AppError[T]) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return e.Message
        }</span>
        <span class="cov8" title="1">return e.Err.Error()</span>
}

func (e *AppError[T]) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

func (e *AppError[T]) ErrorType() T <span class="cov8" title="1">{
        return e.Type
}</span>

// NewAppError creates a new AppError
func NewAppError[T ~string](err error, message, code string, errorType T) *AppError[T] <span class="cov8" title="1">{
        return &amp;AppError[T]{
                Err:     err,
                Message: message,
                Code:    code,
                Type:    errorType,
        }
}</span>

// Map of error codes to HTTP status codes
var errorCodeToHTTPStatus = map[ErrorCode]int{
        NotFoundCode:              http.StatusNotFound,
        InvalidInputCode:          http.StatusBadRequest,
        DatabaseErrorCode:         http.StatusInternalServerError,
        InternalErrorCode:         http.StatusInternalServerError,
        TimeoutCode:               http.StatusGatewayTimeout,
        CanceledCode:              http.StatusRequestTimeout,
        AlreadyExistsCode:         http.StatusConflict,
        UnauthorizedCode:          http.StatusUnauthorized,
        ForbiddenCode:             http.StatusForbidden,
        ValidationErrorCode:       http.StatusBadRequest,
        BusinessRuleViolationCode: http.StatusUnprocessableEntity,
        ExternalServiceErrorCode:  http.StatusBadGateway,
        NetworkErrorCode:          http.StatusServiceUnavailable,
        ConfigurationErrorCode:    http.StatusInternalServerError,
        ResourceExhaustedCode:     http.StatusTooManyRequests,
        DataCorruptionCode:        http.StatusInternalServerError,
        ConcurrencyErrorCode:      http.StatusConflict,
}

// NotFound creates a new error for when a resource is not found.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with NotFoundCode and HTTP 404 status
func NotFound(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", NotFoundCode, http.StatusNotFound, nil)
}</span>

// InvalidInput creates a new error for when input validation fails.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with InvalidInputCode and HTTP 400 status
func InvalidInput(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", InvalidInputCode, http.StatusBadRequest, nil)
}</span>

// DatabaseOperation creates a new error for database operation failures.
// Parameters:
//   - err: The original error
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with DatabaseErrorCode and HTTP 500 status
func DatabaseOperation(err error, format string, args ...interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov8" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov8" title="1">return withContext(err, "database", DatabaseErrorCode, http.StatusInternalServerError, nil)</span>
}

// Internal creates a new error for internal server errors.
// Parameters:
//   - err: The original error
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with InternalErrorCode and HTTP 500 status
func Internal(err error, format string, args ...interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov8" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov8" title="1">return withContext(err, "", InternalErrorCode, http.StatusInternalServerError, nil)</span>
}

// Timeout creates a new error for when an operation times out.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with TimeoutCode and HTTP 504 status
func Timeout(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", TimeoutCode, http.StatusGatewayTimeout, nil)
}</span>

// Canceled creates a new error for when an operation is canceled.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with CanceledCode and HTTP 408 status
func Canceled(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", CanceledCode, http.StatusRequestTimeout, nil)
}</span>

// AlreadyExists creates a new error for when a resource already exists.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with AlreadyExistsCode and HTTP 409 status
func AlreadyExists(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", AlreadyExistsCode, http.StatusConflict, nil)
}</span>

// Unauthorized creates a new error for authentication failures.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with UnauthorizedCode and HTTP 401 status
func Unauthorized(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", UnauthorizedCode, http.StatusUnauthorized, nil)
}</span>

// Forbidden creates a new error for authorization failures.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ForbiddenCode and HTTP 403 status
func Forbidden(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ForbiddenCode, http.StatusForbidden, nil)
}</span>

// Validation creates a new error for domain validation errors.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ValidationErrorCode and HTTP 400 status
func Validation(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ValidationErrorCode, http.StatusBadRequest, nil)
}</span>

// BusinessRuleViolation creates a new error for when a business rule is violated.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with BusinessRuleViolationCode and HTTP 422 status
func BusinessRuleViolation(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", BusinessRuleViolationCode, http.StatusUnprocessableEntity, nil)
}</span>

// ExternalService creates a new error for external service call failures.
// Parameters:
//   - err: The original error
//   - service: The name of the external service
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ExternalServiceErrorCode and HTTP 502 status
func ExternalService(err error, service string, format string, args ...interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov8" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov8" title="1">return withContext(err, fmt.Sprintf("external_service_%s", service), ExternalServiceErrorCode, http.StatusBadGateway, nil)</span>
}

// Network creates a new error for network-related errors.
// Parameters:
//   - err: The original error
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with NetworkErrorCode and HTTP 503 status
func Network(err error, format string, args ...interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov8" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov8" title="1">return withContext(err, "network", NetworkErrorCode, http.StatusServiceUnavailable, nil)</span>
}

// Configuration creates a new error for configuration errors.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ConfigurationErrorCode and HTTP 500 status
func Configuration(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "configuration", ConfigurationErrorCode, http.StatusInternalServerError, nil)
}</span>

// ResourceExhausted creates a new error for when a resource limit is reached.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ResourceExhaustedCode and HTTP 429 status
func ResourceExhausted(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ResourceExhaustedCode, http.StatusTooManyRequests, nil)
}</span>

// DataCorruption creates a new error for when data is corrupted.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with DataCorruptionCode and HTTP 500 status
func DataCorruption(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", DataCorruptionCode, http.StatusInternalServerError, nil)
}</span>

// Concurrency creates a new error for concurrency-related errors.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ConcurrencyErrorCode and HTTP 409 status
func Concurrency(format string, args ...interface{}) error <span class="cov8" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ConcurrencyErrorCode, http.StatusConflict, nil)
}</span>

// Is checks if an error matches a target error.
// This is a wrapper around errors.Is that adds support for ContextualError.
// Parameters:
//   - err: The error to check
//   - target: The target error to match against
//
// Returns:
//   - bool: True if the error matches the target
func Is(err error, target error) bool <span class="cov8" title="1">{
        return errors.Is(err, target)
}</span>

// As finds the first error in err's chain that matches target.
// This is a wrapper around errors.As that adds support for ContextualError.
// Parameters:
//   - err: The error to check
//   - target: A pointer to the error type to match against
//
// Returns:
//   - bool: True if a match was found
func As(err error, target interface{}) bool <span class="cov8" title="1">{
        return errors.As(err, target)
}</span>

// Unwrap returns the underlying error.
// This is a wrapper around errors.Unwrap that adds support for ContextualError.
// Parameters:
//   - err: The error to unwrap
//
// Returns:
//   - error: The underlying error, or nil if there is none
func Unwrap(err error) error <span class="cov8" title="1">{
        return errors.Unwrap(err)
}</span>

// WrapWithOperation wraps an error with an operation name and message.
// It preserves the error chain and adds source location information.
// Parameters:
//   - err: The error to wrap
//   - operation: The name of the operation that failed
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error that wraps the original error
func WrapWithOperation(err error, operation string, format string, args ...interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Get caller information
        <span class="cov8" title="1">source, line := getCallerInfo(1)

        // If the error is already a ContextualError, update its context
        var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov0" title="0">{
                // Create a new ContextualError with the updated message and operation
                return &amp;ContextualError{
                        Original: contextualErr.Original,
                        Context: ErrorContext{
                                Operation:  operation,
                                Source:     source,
                                Line:       line,
                                Code:       contextualErr.Context.Code,
                                HTTPStatus: contextualErr.Context.HTTPStatus,
                                Details:    contextualErr.Context.Details,
                        },
                }
        }</span>

        // Create a new ContextualError
        <span class="cov8" title="1">return &amp;ContextualError{
                Original: err,
                Context: ErrorContext{
                        Operation: operation,
                        Source:    source,
                        Line:      line,
                },
        }</span>
}

// WithDetails adds details to an error.
// It preserves the error chain and adds additional context information.
// Parameters:
//   - err: The error to enhance
//   - details: A map of additional details to add to the error
//
// Returns:
//   - error: A new error with the added details
func WithDetails(err error, details map[string]interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Get caller information
        <span class="cov8" title="1">source, line := getCallerInfo(1)

        // If the error is already a ContextualError, update its context
        var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov0" title="0">{
                // Merge the details
                newDetails := make(map[string]interface{})
                if contextualErr.Context.Details != nil </span><span class="cov0" title="0">{
                        for k, v := range contextualErr.Context.Details </span><span class="cov0" title="0">{
                                newDetails[k] = v
                        }</span>
                }
                <span class="cov0" title="0">for k, v := range details </span><span class="cov0" title="0">{
                        newDetails[k] = v
                }</span>

                // Create a new ContextualError with the merged details
                <span class="cov0" title="0">return &amp;ContextualError{
                        Original: contextualErr.Original,
                        Context: ErrorContext{
                                Operation:  contextualErr.Context.Operation,
                                Source:     source,
                                Line:       line,
                                Code:       contextualErr.Context.Code,
                                HTTPStatus: contextualErr.Context.HTTPStatus,
                                Details:    newDetails,
                        },
                }</span>
        }

        // Create a new ContextualError
        <span class="cov8" title="1">return &amp;ContextualError{
                Original: err,
                Context: ErrorContext{
                        Source:  source,
                        Line:    line,
                        Details: details,
                },
        }</span>
}

// GetCode returns the error code from an error.
// If the error is a ContextualError, it returns the code from the context.
// Otherwise, it returns an empty string.
// Parameters:
//   - err: The error to get the code from
//
// Returns:
//   - ErrorCode: The error code, or an empty string if not available
func GetCode(err error) ErrorCode <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov8" title="1">{
                return contextualErr.Context.Code
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// GetHTTPStatus returns the HTTP status code from an error.
// If the error is a ContextualError, it returns the HTTP status from the context.
// Otherwise, it returns 0.
// Parameters:
//   - err: The error to get the HTTP status from
//
// Returns:
//   - int: The HTTP status code, or 0 if not available
func GetHTTPStatus(err error) int <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov8" title="1">{
                return contextualErr.Context.HTTPStatus
        }</span>

        <span class="cov8" title="1">return 0</span>
}

// ToJSON converts an error to a JSON string.
// If the error is a ContextualError, it uses the MarshalJSON method.
// Otherwise, it creates a simple JSON object with the error message.
// Parameters:
//   - err: The error to convert to JSON
//
// Returns:
//   - string: The JSON representation of the error
func ToJSON(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return "{}"
        }</span>

        <span class="cov8" title="1">var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov8" title="1">{
                jsonBytes, jsonErr := json.Marshal(contextualErr)
                if jsonErr != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`{"message":"Error marshaling error to JSON: %s"}`, jsonErr.Error())
                }</span>
                <span class="cov8" title="1">return string(jsonBytes)</span>
        }

        // For non-ContextualError errors, create a simple JSON object
        <span class="cov8" title="1">jsonBytes, jsonErr := json.Marshal(struct {
                Message string `json:"message"`
        }{
                Message: err.Error(),
        })
        if jsonErr != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"message":"Error marshaling error to JSON: %s"}`, jsonErr.Error())
        }</span>
        <span class="cov8" title="1">return string(jsonBytes)</span>
}

// DomainErrorType represents the type of domain error
type DomainErrorType string

// Domain error type constants
const (
        DomainErrorGeneral DomainErrorType = "DOMAIN_ERROR"
)

// DomainError represents an error that occurred in the domain layer
type DomainError = AppError[DomainErrorType]

// NewDomainError creates a new DomainError
func NewDomainError(err error, message, code string) *DomainError <span class="cov8" title="1">{
        return NewAppError(err, message, code, DomainErrorGeneral)
}</span>

// ValidationError represents a validation error
type ValidationError struct {
        Msg   string
        Field string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        if e.Field != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("validation error: %s (field: %s)", e.Msg, e.Field)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("validation error: %s", e.Msg)</span>
}

// NewValidationError creates a new ValidationError
func NewValidationError(msg string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{Msg: msg}
}</span>

// NewFieldValidationError creates a new ValidationError with a field name
func NewFieldValidationError(msg, field string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{Msg: msg, Field: field}
}</span>

// ValidationErrors represents multiple validation errors
type ValidationErrors struct {
        Errors []*ValidationError
}

func (e *ValidationErrors) Error() string <span class="cov8" title="1">{
        if len(e.Errors) == 1 </span><span class="cov8" title="1">{
                return e.Errors[0].Error()
        }</span>

        <span class="cov8" title="1">msg := fmt.Sprintf("%d validation errors:", len(e.Errors))
        for i, err := range e.Errors </span><span class="cov8" title="1">{
                msg += fmt.Sprintf("\n  %d. %s", i+1, err.Error())
        }</span>
        <span class="cov8" title="1">return msg</span>
}

// NewValidationErrors creates a new ValidationErrors
func NewValidationErrors(errors ...*ValidationError) *ValidationErrors <span class="cov8" title="1">{
        return &amp;ValidationErrors{Errors: errors}
}</span>

// AddError adds a validation error to the collection
func (e *ValidationErrors) AddError(err *ValidationError) <span class="cov8" title="1">{
        e.Errors = append(e.Errors, err)
}</span>

// HasErrors returns true if there are any validation errors
func (e *ValidationErrors) HasErrors() bool <span class="cov8" title="1">{
        return len(e.Errors) &gt; 0
}</span>

// RepositoryError represents an error that occurred in the repository layer
type RepositoryError struct {
        Err     error
        Message string
        Code    string
}

func (e *RepositoryError) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return e.Message
        }</span>
        <span class="cov8" title="1">return e.Err.Error()</span>
}

func (e *RepositoryError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewRepositoryError creates a new RepositoryError
func NewRepositoryError(err error, message, code string) *RepositoryError <span class="cov8" title="1">{
        return &amp;RepositoryError{
                Err:     err,
                Message: message,
                Code:    code,
        }
}</span>

// NotFoundError represents a resource not found error
type NotFoundError struct {
        ResourceType string
        ID           string
}

func (e *NotFoundError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s with ID %s not found", e.ResourceType, e.ID)
}</span>

// NewNotFoundError creates a new NotFoundError
func NewNotFoundError(resourceType, id string) *NotFoundError <span class="cov8" title="1">{
        return &amp;NotFoundError{
                ResourceType: resourceType,
                ID:           id,
        }
}</span>

// Is implements the errors.Is interface for NotFoundError
func (e *NotFoundError) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrNotFound
}</span>

// ApplicationError represents an error that occurred in the application layer
type ApplicationError struct {
        Err     error
        Message string
        Code    string
}

func (e *ApplicationError) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return e.Message
        }</span>
        <span class="cov8" title="1">return e.Err.Error()</span>
}

func (e *ApplicationError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewApplicationError creates a new ApplicationError
func NewApplicationError(err error, message, code string) *ApplicationError <span class="cov8" title="1">{
        return &amp;ApplicationError{
                Err:     err,
                Message: message,
                Code:    code,
        }
}</span>

// Error represents a domain error with operation context
type Error struct {
        // Original is the original error
        Original error

        // Code is a machine-readable error code
        Code string

        // Message is a human-readable error message
        Message string

        // Op is the operation that caused the error
        Op string

        // Param is the parameter that caused the error
        Param string
}

// Error returns a string representation of the error
func (e *Error) Error() string <span class="cov8" title="1">{
        if e.Original != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %s: %v", e.Op, e.Message, e.Original)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s: %s", e.Op, e.Message)</span>
}

// Unwrap returns the original error
func (e *Error) Unwrap() error <span class="cov8" title="1">{
        return e.Original
}</span>

// Is reports whether the error is of the given target type
func (e *Error) Is(target error) bool <span class="cov8" title="1">{
        if target == nil </span><span class="cov8" title="1">{
                return e == nil
        }</span>

        <span class="cov8" title="1">t, ok := target.(*Error)
        if !ok </span><span class="cov8" title="1">{
                return errors.Is(e.Original, target)
        }</span>

        <span class="cov8" title="1">return e.Code == t.Code</span>
}

// New creates a new Error
func New(op, code, message string, original error) error <span class="cov8" title="1">{
        return &amp;Error{
                Original: original,
                Code:     code,
                Message:  message,
                Op:       op,
        }
}</span>

// Wrap wraps an error with additional context
func Wrap(err error, op, message string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If it's already a domain error, just update the op and message
        <span class="cov8" title="1">if e, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return &amp;Error{
                        Original: e.Original,
                        Code:     e.Code,
                        Message:  message,
                        Op:       op,
                }
        }</span>

        // Otherwise, create a new domain error
        <span class="cov8" title="1">return &amp;Error{
                Original: err,
                Message:  message,
                Op:       op,
        }</span>
}

// IsNotFound returns true if the error is a not found error
func IsNotFound(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrNotFound)
}</span>

// IsInvalidInput returns true if the error is an invalid input error
func IsInvalidInput(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrInvalidInput)
}</span>

// IsUnauthorized returns true if the error is an unauthorized error
func IsUnauthorized(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrUnauthorized)
}</span>

// IsForbidden returns true if the error is a forbidden error
func IsForbidden(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrForbidden)
}</span>

// IsInternal returns true if the error is an internal error
func IsInternal(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrInternal)
}</span>

// IsTimeout returns true if the error is a timeout error
func IsTimeout(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrTimeout)
}</span>

// IsCancelled returns true if the error is a cancelled error
func IsCancelled(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrCancelled)
}</span>

// IsConflict returns true if the error is a conflict error
func IsConflict(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrConflict)
}</span>

// GenericError is a generic error type that can be used for different error categories
type GenericError[T any] struct {
        Err      error
        Message  string
        Code     string
        Category T
}

func (e *GenericError[T]) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return e.Message
        }</span>
        <span class="cov8" title="1">return e.Err.Error()</span>
}

func (e *GenericError[T]) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewGenericError creates a new GenericError
func NewGenericError[T any](err error, message, code string, category T) *GenericError[T] <span class="cov8" title="1">{
        return &amp;GenericError[T]{
                Err:      err,
                Message:  message,
                Code:     code,
                Category: category,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package errors provides generic error interfaces and implementations that can be used across different applications.
package errors

import (
        "net/http"
)

// ErrorWithCode is an interface for errors that have an error code
type ErrorWithCode interface {
        error
        // Code returns the error code
        Code() string
}

// ErrorWithHTTPStatus is an interface for errors that have an HTTP status code
type ErrorWithHTTPStatus interface {
        error
        // HTTPStatus returns the HTTP status code
        HTTPStatus() int
}

// ValidationErrorInterface is an interface for validation errors
type ValidationErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsValidationError identifies this as a validation error
        IsValidationError() bool
}

// NotFoundErrorInterface is an interface for not found errors
type NotFoundErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsNotFoundError identifies this as a not found error
        IsNotFoundError() bool
}

// ApplicationErrorInterface is an interface for application errors
type ApplicationErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsApplicationError identifies this as an application error
        IsApplicationError() bool
}

// RepositoryErrorInterface is an interface for repository errors
type RepositoryErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsRepositoryError identifies this as a repository error
        IsRepositoryError() bool
}

// IsValidationError checks if an error is a validation error
func IsValidationError(err error) bool <span class="cov8" title="1">{
        var validationErr ValidationErrorInterface
        return As(err, &amp;validationErr)
}</span>

// IsNotFoundError checks if an error is a not found error
func IsNotFoundError(err error) bool <span class="cov8" title="1">{
        var notFoundErr NotFoundErrorInterface
        return As(err, &amp;notFoundErr)
}</span>

// IsApplicationError checks if an error is an application error
func IsApplicationError(err error) bool <span class="cov8" title="1">{
        var appErr ApplicationErrorInterface
        return As(err, &amp;appErr)
}</span>

// IsRepositoryError checks if an error is a repository error
func IsRepositoryError(err error) bool <span class="cov8" title="1">{
        var repoErr RepositoryErrorInterface
        return As(err, &amp;repoErr)
}</span>

// GetHTTPStatusFromError returns the HTTP status code for an error
func GetHTTPStatusFromError(err error) int <span class="cov8" title="1">{
        // Check if the error implements ErrorWithHTTPStatus
        if httpErr, ok := err.(ErrorWithHTTPStatus); ok </span><span class="cov8" title="1">{
                return httpErr.HTTPStatus()
        }</span>
        
        // Check specific error types
        <span class="cov8" title="1">if IsValidationError(err) </span><span class="cov0" title="0">{
                return http.StatusBadRequest
        }</span>
        <span class="cov8" title="1">if IsNotFoundError(err) </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">if IsApplicationError(err) || IsRepositoryError(err) </span><span class="cov0" title="0">{
                return http.StatusInternalServerError
        }</span>
        
        // Default status code
        <span class="cov8" title="1">return http.StatusInternalServerError</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/abitofhelp/servicelib/errors (interfaces: ErrorWithCode,ErrorWithHTTPStatus,ValidationErrorInterface,NotFoundErrorInterface,ApplicationErrorInterface,RepositoryErrorInterface)

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockErrorWithCode is a mock of ErrorWithCode interface.
type MockErrorWithCode struct {
        ctrl     *gomock.Controller
        recorder *MockErrorWithCodeMockRecorder
}

// MockErrorWithCodeMockRecorder is the mock recorder for MockErrorWithCode.
type MockErrorWithCodeMockRecorder struct {
        mock *MockErrorWithCode
}

// NewMockErrorWithCode creates a new mock instance.
func NewMockErrorWithCode(ctrl *gomock.Controller) *MockErrorWithCode <span class="cov0" title="0">{
        mock := &amp;MockErrorWithCode{ctrl: ctrl}
        mock.recorder = &amp;MockErrorWithCodeMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorWithCode) EXPECT() *MockErrorWithCodeMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockErrorWithCode) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockErrorWithCodeMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockErrorWithCode)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockErrorWithCode) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockErrorWithCodeMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockErrorWithCode)(nil).Error))
}</span>

// MockErrorWithHTTPStatus is a mock of ErrorWithHTTPStatus interface.
type MockErrorWithHTTPStatus struct {
        ctrl     *gomock.Controller
        recorder *MockErrorWithHTTPStatusMockRecorder
}

// MockErrorWithHTTPStatusMockRecorder is the mock recorder for MockErrorWithHTTPStatus.
type MockErrorWithHTTPStatusMockRecorder struct {
        mock *MockErrorWithHTTPStatus
}

// NewMockErrorWithHTTPStatus creates a new mock instance.
func NewMockErrorWithHTTPStatus(ctrl *gomock.Controller) *MockErrorWithHTTPStatus <span class="cov0" title="0">{
        mock := &amp;MockErrorWithHTTPStatus{ctrl: ctrl}
        mock.recorder = &amp;MockErrorWithHTTPStatusMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorWithHTTPStatus) EXPECT() *MockErrorWithHTTPStatusMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Error mocks base method.
func (m *MockErrorWithHTTPStatus) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockErrorWithHTTPStatusMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockErrorWithHTTPStatus)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockErrorWithHTTPStatus) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockErrorWithHTTPStatusMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockErrorWithHTTPStatus)(nil).HTTPStatus))
}</span>

// MockValidationErrorInterface is a mock of ValidationErrorInterface interface.
type MockValidationErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockValidationErrorInterfaceMockRecorder
}

// MockValidationErrorInterfaceMockRecorder is the mock recorder for MockValidationErrorInterface.
type MockValidationErrorInterfaceMockRecorder struct {
        mock *MockValidationErrorInterface
}

// NewMockValidationErrorInterface creates a new mock instance.
func NewMockValidationErrorInterface(ctrl *gomock.Controller) *MockValidationErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockValidationErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockValidationErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockValidationErrorInterface) EXPECT() *MockValidationErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockValidationErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockValidationErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockValidationErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockValidationErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockValidationErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockValidationErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockValidationErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockValidationErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockValidationErrorInterface)(nil).HTTPStatus))
}</span>

// IsValidationError mocks base method.
func (m *MockValidationErrorInterface) IsValidationError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsValidationError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsValidationError indicates an expected call of IsValidationError.
func (mr *MockValidationErrorInterfaceMockRecorder) IsValidationError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsValidationError", reflect.TypeOf((*MockValidationErrorInterface)(nil).IsValidationError))
}</span>

// MockNotFoundErrorInterface is a mock of NotFoundErrorInterface interface.
type MockNotFoundErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockNotFoundErrorInterfaceMockRecorder
}

// MockNotFoundErrorInterfaceMockRecorder is the mock recorder for MockNotFoundErrorInterface.
type MockNotFoundErrorInterfaceMockRecorder struct {
        mock *MockNotFoundErrorInterface
}

// NewMockNotFoundErrorInterface creates a new mock instance.
func NewMockNotFoundErrorInterface(ctrl *gomock.Controller) *MockNotFoundErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockNotFoundErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockNotFoundErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotFoundErrorInterface) EXPECT() *MockNotFoundErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockNotFoundErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockNotFoundErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockNotFoundErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockNotFoundErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockNotFoundErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockNotFoundErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).HTTPStatus))
}</span>

// IsNotFoundError mocks base method.
func (m *MockNotFoundErrorInterface) IsNotFoundError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsNotFoundError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsNotFoundError indicates an expected call of IsNotFoundError.
func (mr *MockNotFoundErrorInterfaceMockRecorder) IsNotFoundError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNotFoundError", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).IsNotFoundError))
}</span>

// MockApplicationErrorInterface is a mock of ApplicationErrorInterface interface.
type MockApplicationErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockApplicationErrorInterfaceMockRecorder
}

// MockApplicationErrorInterfaceMockRecorder is the mock recorder for MockApplicationErrorInterface.
type MockApplicationErrorInterfaceMockRecorder struct {
        mock *MockApplicationErrorInterface
}

// NewMockApplicationErrorInterface creates a new mock instance.
func NewMockApplicationErrorInterface(ctrl *gomock.Controller) *MockApplicationErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockApplicationErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockApplicationErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplicationErrorInterface) EXPECT() *MockApplicationErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockApplicationErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockApplicationErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockApplicationErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockApplicationErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockApplicationErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockApplicationErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockApplicationErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockApplicationErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockApplicationErrorInterface)(nil).HTTPStatus))
}</span>

// IsApplicationError mocks base method.
func (m *MockApplicationErrorInterface) IsApplicationError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsApplicationError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsApplicationError indicates an expected call of IsApplicationError.
func (mr *MockApplicationErrorInterfaceMockRecorder) IsApplicationError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsApplicationError", reflect.TypeOf((*MockApplicationErrorInterface)(nil).IsApplicationError))
}</span>

// MockRepositoryErrorInterface is a mock of RepositoryErrorInterface interface.
type MockRepositoryErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryErrorInterfaceMockRecorder
}

// MockRepositoryErrorInterfaceMockRecorder is the mock recorder for MockRepositoryErrorInterface.
type MockRepositoryErrorInterfaceMockRecorder struct {
        mock *MockRepositoryErrorInterface
}

// NewMockRepositoryErrorInterface creates a new mock instance.
func NewMockRepositoryErrorInterface(ctrl *gomock.Controller) *MockRepositoryErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockRepositoryErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryErrorInterface) EXPECT() *MockRepositoryErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockRepositoryErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockRepositoryErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockRepositoryErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockRepositoryErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockRepositoryErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockRepositoryErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).HTTPStatus))
}</span>

// IsRepositoryError mocks base method.
func (m *MockRepositoryErrorInterface) IsRepositoryError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsRepositoryError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsRepositoryError indicates an expected call of IsRepositoryError.
func (mr *MockRepositoryErrorInterfaceMockRecorder) IsRepositoryError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRepositoryError", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).IsRepositoryError))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
