
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/abitofhelp/servicelib/auth/jwt.go (76.0%)</option>
				
				<option value="file1">github.com/abitofhelp/servicelib/auth/oauth2/oauth2.go (100.0%)</option>
				
				<option value="file2">github.com/abitofhelp/servicelib/auth/oidc/oidc.go (100.0%)</option>
				
				<option value="file3">github.com/abitofhelp/servicelib/config/adapter.go (57.7%)</option>
				
				<option value="file4">github.com/abitofhelp/servicelib/config/mocks/mock_config.go (0.0%)</option>
				
				<option value="file5">github.com/abitofhelp/servicelib/context/context.go (57.7%)</option>
				
				<option value="file6">github.com/abitofhelp/servicelib/date/date.go (100.0%)</option>
				
				<option value="file7">github.com/abitofhelp/servicelib/db/db.go (30.0%)</option>
				
				<option value="file8">github.com/abitofhelp/servicelib/db/mocks/mock_db.go (0.0%)</option>
				
				<option value="file9">github.com/abitofhelp/servicelib/di/base_container.go (100.0%)</option>
				
				<option value="file10">github.com/abitofhelp/servicelib/di/container.go (100.0%)</option>
				
				<option value="file11">github.com/abitofhelp/servicelib/di/db_initializers.go (0.0%)</option>
				
				<option value="file12">github.com/abitofhelp/servicelib/di/generic_container.go (0.0%)</option>
				
				<option value="file13">github.com/abitofhelp/servicelib/di/generic_repository_container.go (0.0%)</option>
				
				<option value="file14">github.com/abitofhelp/servicelib/di/repository_container.go (100.0%)</option>
				
				<option value="file15">github.com/abitofhelp/servicelib/di/repository_initializers.go (0.0%)</option>
				
				<option value="file16">github.com/abitofhelp/servicelib/di/service_container.go (0.0%)</option>
				
				<option value="file17">github.com/abitofhelp/servicelib/env/env.go (100.0%)</option>
				
				<option value="file18">github.com/abitofhelp/servicelib/errors/errors.go (76.0%)</option>
				
				<option value="file19">github.com/abitofhelp/servicelib/errors/interfaces.go (82.4%)</option>
				
				<option value="file20">github.com/abitofhelp/servicelib/errors/mocks/mock_interfaces.go (0.0%)</option>
				
				<option value="file21">github.com/abitofhelp/servicelib/graphql/errors.go (0.0%)</option>
				
				<option value="file22">github.com/abitofhelp/servicelib/graphql/server.go (0.0%)</option>
				
				<option value="file23">github.com/abitofhelp/servicelib/health/adapter.go (0.0%)</option>
				
				<option value="file24">github.com/abitofhelp/servicelib/health/config_adapter.go (0.0%)</option>
				
				<option value="file25">github.com/abitofhelp/servicelib/health/factory.go (0.0%)</option>
				
				<option value="file26">github.com/abitofhelp/servicelib/health/generic_handler.go (0.0%)</option>
				
				<option value="file27">github.com/abitofhelp/servicelib/health/handler.go (0.0%)</option>
				
				<option value="file28">github.com/abitofhelp/servicelib/health/repository_adapter.go (0.0%)</option>
				
				<option value="file29">github.com/abitofhelp/servicelib/health/version_provider.go (0.0%)</option>
				
				<option value="file30">github.com/abitofhelp/servicelib/logging/logger.go (96.0%)</option>
				
				<option value="file31">github.com/abitofhelp/servicelib/middleware/middleware.go (0.0%)</option>
				
				<option value="file32">github.com/abitofhelp/servicelib/model/conversion.go (92.9%)</option>
				
				<option value="file33">github.com/abitofhelp/servicelib/repository/mocks/mock_repository.go (0.0%)</option>
				
				<option value="file34">github.com/abitofhelp/servicelib/shutdown/shutdown.go (0.0%)</option>
				
				<option value="file35">github.com/abitofhelp/servicelib/signal/signal.go (0.0%)</option>
				
				<option value="file36">github.com/abitofhelp/servicelib/stringutil/strings.go (100.0%)</option>
				
				<option value="file37">github.com/abitofhelp/servicelib/telemetry/config.go (0.0%)</option>
				
				<option value="file38">github.com/abitofhelp/servicelib/telemetry/http.go (0.0%)</option>
				
				<option value="file39">github.com/abitofhelp/servicelib/telemetry/metrics.go (0.0%)</option>
				
				<option value="file40">github.com/abitofhelp/servicelib/tracing/http.go (0.0%)</option>
				
				<option value="file41">github.com/abitofhelp/servicelib/tracing/metrics.go (0.0%)</option>
				
				<option value="file42">github.com/abitofhelp/servicelib/tracing/telemetry.go (0.0%)</option>
				
				<option value="file43">github.com/abitofhelp/servicelib/tracing/tracing.go (0.0%)</option>
				
				<option value="file44">github.com/abitofhelp/servicelib/transaction/saga/saga.go (0.0%)</option>
				
				<option value="file45">github.com/abitofhelp/servicelib/validation/validate.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package auth provides authentication and authorization functionality.
// It includes JWT token handling for securing API endpoints.
// This package is designed to be reusable across different applications.
package auth

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "go.uber.org/zap"
)

// JWTConfig holds the configuration for JWT token handling.
// It contains the necessary parameters for creating and validating JWT tokens.
type JWTConfig struct {
        // SecretKey is the key used to sign and verify JWT tokens
        SecretKey string

        // TokenDuration is the validity period for generated tokens
        TokenDuration time.Duration

        // Issuer identifies the entity that issued the token
        Issuer string
}

// JWTService handles JWT token operations including generation and validation.
// It implements token-based authentication for the application.
type JWTService struct {
        // config contains the JWT configuration parameters
        config JWTConfig

        // logger is used for logging token operations and errors
        logger *zap.Logger
}

// NewJWTService creates a new JWT service with the provided configuration and logger.
// Parameters:
//   - config: The configuration for JWT token handling
//   - logger: The logger for recording operations and errors
//
// Returns:
//   - *JWTService: A new instance of the JWT service
func NewJWTService(config JWTConfig, logger *zap.Logger) *JWTService <span class="cov10" title="10">{
        return &amp;JWTService{
                config: config,
                logger: logger,
        }
}</span>

// Claims represents the JWT claims contained in a token.
// It extends the standard JWT registered claims with custom application-specific claims.
type Claims struct {
        // UserID is the unique identifier of the user (stored in the 'sub' claim)
        UserID string `json:"sub"`

        // Roles contains the user's assigned roles for authorization
        Roles []string `json:"roles"`

        // RegisteredClaims contains the standard JWT claims like expiration time
        jwt.RegisteredClaims
}

// GenerateToken generates a new JWT token for a user with the specified roles.
// It creates a token with claims including user ID, roles, and standard JWT claims
// like expiration time, issued at time, and issuer.
// Parameters:
//   - userID: The unique identifier of the user
//   - roles: The roles assigned to the user for authorization purposes
//
// Returns:
//   - string: The signed JWT token string if successful
//   - error: An error if token generation fails
func (s *JWTService) GenerateToken(userID string, roles []string) (string, error) <span class="cov8" title="7">{
        now := time.Now()
        expiresAt := now.Add(s.config.TokenDuration)

        claims := Claims{
                UserID: userID,
                Roles:  roles,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    s.config.Issuer,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(s.config.SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to generate token", zap.Error(err))
                return "", fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov8" title="7">return tokenString, nil</span>
}

// ValidateToken validates a JWT token and returns the claims if valid.
// It verifies the token signature, checks if the token is expired,
// and extracts the claims from the token.
// Parameters:
//   - tokenString: The JWT token string to validate
//
// Returns:
//   - *Claims: The claims from the token if validation is successful
//   - error: An error if token validation fails for any reason
func (s *JWTService) ValidateToken(tokenString string) (*Claims, error) <span class="cov8" title="7">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov7" title="5">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>

                <span class="cov6" title="4">return []byte(s.config.SecretKey), nil</span>
        })

        <span class="cov8" title="7">if err != nil </span><span class="cov7" title="5">{
                s.logger.Debug("Failed to parse token", zap.Error(err))
                return nil, fmt.Errorf("invalid token: %w", err)
        }</span>

        <span class="cov3" title="2">if !token.Valid </span><span class="cov0" title="0">{
                s.logger.Debug("Invalid token")
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov3" title="2">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to extract claims from token")
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov3" title="2">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package oauth2 provides OAuth2 authentication functionality for the family-service-graphql.
// This functionality is currently not enabled but will be in the future.
package oauth2

// Config represents the configuration for OAuth2 authentication.
type Config struct {
        // ClientID is the application's ID.
        ClientID string

        // ClientSecret is the application's secret.
        ClientSecret string

        // RedirectURL is the URL to redirect users going through
        // the OAuth flow.
        RedirectURL string

        // Scopes specifies optional requested permissions.
        Scopes []string
}

// Provider represents an OAuth2 provider.
type Provider struct {
        // Config is the OAuth2 configuration.
        Config *Config
}

// NewProvider creates a new OAuth2 provider with the given configuration.
// Note: This functionality is not currently enabled.
func NewProvider(config *Config) *Provider <span class="cov8" title="1">{
        return &amp;Provider{
                Config: config,
        }
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package oidc provides OpenID Connect (OIDC) authorization functionality for the family-service-graphql.
// This functionality is currently not enabled but will be in the future.
package oidc

// Config represents the configuration for OIDC authorization.
type Config struct {
        // Issuer is the URL of the OpenID Connect provider.
        Issuer string

        // ClientID is the application's ID.
        ClientID string

        // ClientSecret is the application's secret.
        ClientSecret string

        // RedirectURL is the URL to redirect users going through
        // the OIDC flow.
        RedirectURL string

        // Scopes specifies optional requested permissions.
        Scopes []string
}

// Provider represents an OIDC provider.
type Provider struct {
        // Config is the OIDC configuration.
        Config *Config
}

// NewProvider creates a new OIDC provider with the given configuration.
// Note: This functionality is not currently enabled.
func NewProvider(config *Config) *Provider <span class="cov8" title="1">{
        return &amp;Provider{
                Config: config,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package config provides generic configuration interfaces and adapters.
package config

// AppConfigProvider defines the interface for accessing application configuration
type AppConfigProvider interface {
        // GetAppVersion returns the application version
        GetAppVersion() string

        // GetAppName returns the application name (optional)
        GetAppName() string

        // GetAppEnvironment returns the application environment (optional)
        GetAppEnvironment() string
}

// DatabaseConfigProvider defines the interface for accessing database configuration
type DatabaseConfigProvider interface {
        // GetDatabaseType returns the database type
        GetDatabaseType() string

        // GetDatabaseConnectionString returns the database connection string
        GetDatabaseConnectionString(dbType string) string
}

// GenericConfigAdapter is a generic adapter for any config type that provides the necessary methods
type GenericConfigAdapter[T any] struct {
        config T
        appName string
        appEnvironment string
        dbName string
}

// NewGenericConfigAdapter creates a new GenericConfigAdapter with default values
func NewGenericConfigAdapter[T any](cfg T) *GenericConfigAdapter[T] <span class="cov10" title="8">{
        return &amp;GenericConfigAdapter[T]{
                config: cfg,
                appName: "application",
                appEnvironment: "development",
                dbName: "database",
        }
}</span>

// WithAppName sets the application name
func (a *GenericConfigAdapter[T]) WithAppName(name string) *GenericConfigAdapter[T] <span class="cov0" title="0">{
        a.appName = name
        return a
}</span>

// WithAppEnvironment sets the application environment
func (a *GenericConfigAdapter[T]) WithAppEnvironment(env string) *GenericConfigAdapter[T] <span class="cov0" title="0">{
        a.appEnvironment = env
        return a
}</span>

// WithDatabaseName sets the database name
func (a *GenericConfigAdapter[T]) WithDatabaseName(name string) *GenericConfigAdapter[T] <span class="cov0" title="0">{
        a.dbName = name
        return a
}</span>

// GetApp returns the application configuration
func (a *GenericConfigAdapter[T]) GetApp() AppConfig <span class="cov1" title="1">{
        return &amp;GenericAppConfigAdapter[T]{
                config: a.config,
                appName: a.appName,
                appEnvironment: a.appEnvironment,
        }
}</span>

// GetDatabase returns the database configuration
func (a *GenericConfigAdapter[T]) GetDatabase() DatabaseConfig <span class="cov8" title="6">{
        return &amp;GenericDatabaseConfigAdapter[T]{
                config: a.config,
                dbName: a.dbName,
        }
}</span>

// GenericAppConfigAdapter is a generic adapter for application configuration
type GenericAppConfigAdapter[T any] struct {
        config T
        appName string
        appEnvironment string
}

// GetVersion returns the application version
func (a *GenericAppConfigAdapter[T]) GetVersion() string <span class="cov1" title="1">{
        if provider, ok := any(a.config).(AppConfigProvider); ok </span><span class="cov1" title="1">{
                return provider.GetAppVersion()
        }</span>
        <span class="cov0" title="0">return "1.0.0"</span> // Default version
}

// GetName returns the application name
func (a *GenericAppConfigAdapter[T]) GetName() string <span class="cov1" title="1">{
        if provider, ok := any(a.config).(AppConfigProvider); ok </span><span class="cov1" title="1">{
                return provider.GetAppName()
        }</span>
        <span class="cov0" title="0">return a.appName</span>
}

// GetEnvironment returns the application environment
func (a *GenericAppConfigAdapter[T]) GetEnvironment() string <span class="cov1" title="1">{
        if provider, ok := any(a.config).(AppConfigProvider); ok </span><span class="cov1" title="1">{
                return provider.GetAppEnvironment()
        }</span>
        <span class="cov0" title="0">return a.appEnvironment</span>
}

// GenericDatabaseConfigAdapter is a generic adapter for database configuration
type GenericDatabaseConfigAdapter[T any] struct {
        config T
        dbName string
}

// GetType returns the database type
func (a *GenericDatabaseConfigAdapter[T]) GetType() string <span class="cov10" title="8">{
        if provider, ok := any(a.config).(DatabaseConfigProvider); ok </span><span class="cov10" title="8">{
                return provider.GetDatabaseType()
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// GetConnectionString returns the database connection string
func (a *GenericDatabaseConfigAdapter[T]) GetConnectionString() string <span class="cov7" title="4">{
        if provider, ok := any(a.config).(DatabaseConfigProvider); ok </span><span class="cov7" title="4">{
                return provider.GetDatabaseConnectionString(a.GetType())
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetDatabaseName returns the database name
func (a *GenericDatabaseConfigAdapter[T]) GetDatabaseName() string <span class="cov7" title="4">{
        return a.dbName
}</span>

// GetCollectionName returns the collection/table name for a given entity type
func (a *GenericDatabaseConfigAdapter[T]) GetCollectionName(entityType string) string <span class="cov4" title="2">{
        // Simple pluralization
        return entityType + "s"
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/abitofhelp/servicelib/config (interfaces: ConfigInterface)

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockConfigInterface is a mock of ConfigInterface interface.
type MockConfigInterface struct {
        ctrl     *gomock.Controller
        recorder *MockConfigInterfaceMockRecorder
}

// MockConfigInterfaceMockRecorder is the mock recorder for MockConfigInterface.
type MockConfigInterfaceMockRecorder struct {
        mock *MockConfigInterface
}

// NewMockConfigInterface creates a new mock instance.
func NewMockConfigInterface(ctrl *gomock.Controller) *MockConfigInterface <span class="cov0" title="0">{
        mock := &amp;MockConfigInterface{ctrl: ctrl}
        mock.recorder = &amp;MockConfigInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfigInterface) EXPECT() *MockConfigInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetApp mocks base method.
func (m *MockConfigInterface) GetApp() interface{} <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetApp")
        ret0, _ := ret[0].(interface{})
        return ret0
}</span>

// GetApp indicates an expected call of GetApp.
func (mr *MockConfigInterfaceMockRecorder) GetApp() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApp", reflect.TypeOf((*MockConfigInterface)(nil).GetApp))
}</span>

// GetDatabase mocks base method.
func (m *MockConfigInterface) GetDatabase() interface{} <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetDatabase")
        ret0, _ := ret[0].(interface{})
        return ret0
}</span>

// GetDatabase indicates an expected call of GetDatabase.
func (mr *MockConfigInterfaceMockRecorder) GetDatabase() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDatabase", reflect.TypeOf((*MockConfigInterface)(nil).GetDatabase))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package context provides utilities for working with Go's context package.
// It includes functions for creating contexts with various timeouts, adding and retrieving
// values from contexts, and checking context status.
package context

import (
        "context"
        "fmt"
        "time"

        "github.com/abitofhelp/servicelib/errors"
        "github.com/google/uuid"
)

// Key represents a key for context values
type Key string

// Context keys
const (
        RequestIDKey     Key = "request_id"
        TraceIDKey       Key = "trace_id"
        UserIDKey        Key = "user_id"
        TenantIDKey      Key = "tenant_id"
        OperationKey     Key = "operation"
        CorrelationIDKey Key = "correlation_id"
        ServiceNameKey   Key = "service_name"
)

// Default timeout values
const (
        DefaultTimeout         = 30 * time.Second
        ShortTimeout           = 5 * time.Second
        LongTimeout            = 60 * time.Second
        DatabaseTimeout        = 10 * time.Second
        NetworkTimeout         = 15 * time.Second
        ExternalServiceTimeout = 20 * time.Second
)

// ContextOptions contains options for creating a context
type ContextOptions struct {
        // Timeout is the duration after which the context will be canceled
        Timeout time.Duration

        // RequestID is a unique identifier for the request
        RequestID string

        // TraceID is a unique identifier for tracing
        TraceID string

        // UserID is the ID of the user making the request
        UserID string

        // TenantID is the ID of the tenant
        TenantID string

        // Operation is the name of the operation being performed
        Operation string

        // CorrelationID is a unique identifier for correlating related operations
        CorrelationID string

        // ServiceName is the name of the service
        ServiceName string

        // Parent is the parent context
        Parent context.Context
}

// NewContext creates a new context with the specified options
func NewContext(opts ContextOptions) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        if opts.Parent == nil </span><span class="cov0" title="0">{
                opts.Parent = context.Background()
        }</span>

        <span class="cov0" title="0">if opts.Timeout &gt; 0 </span><span class="cov0" title="0">{
                return WithTimeout(opts.Parent, opts.Timeout, opts)
        }</span>

        // If no timeout is specified, create a context with cancel
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(opts.Parent)
        return enrichContext(ctx, opts), cancel</span>
}

// WithTimeout creates a new context with the specified timeout and options
func WithTimeout(ctx context.Context, timeout time.Duration, opts ContextOptions) (context.Context, context.CancelFunc) <span class="cov7" title="4">{
        timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
        return enrichContext(timeoutCtx, opts), cancel
}</span>

// enrichContext adds the specified options to the context
func enrichContext(ctx context.Context, opts ContextOptions) context.Context <span class="cov7" title="4">{
        if opts.RequestID != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, RequestIDKey, opts.RequestID)
        }</span> else<span class="cov7" title="4"> if GetRequestID(ctx) == "" </span><span class="cov7" title="4">{
                ctx = context.WithValue(ctx, RequestIDKey, uuid.New().String())
        }</span>

        <span class="cov7" title="4">if opts.TraceID != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, TraceIDKey, opts.TraceID)
        }</span> else<span class="cov7" title="4"> if GetTraceID(ctx) == "" </span><span class="cov7" title="4">{
                ctx = context.WithValue(ctx, TraceIDKey, uuid.New().String())
        }</span>

        <span class="cov7" title="4">if opts.UserID != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, UserIDKey, opts.UserID)
        }</span>

        <span class="cov7" title="4">if opts.TenantID != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, TenantIDKey, opts.TenantID)
        }</span>

        <span class="cov7" title="4">if opts.Operation != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, OperationKey, opts.Operation)
        }</span>

        <span class="cov7" title="4">if opts.CorrelationID != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, CorrelationIDKey, opts.CorrelationID)
        }</span> else<span class="cov7" title="4"> if GetCorrelationID(ctx) == "" </span><span class="cov7" title="4">{
                ctx = context.WithValue(ctx, CorrelationIDKey, uuid.New().String())
        }</span>

        <span class="cov7" title="4">if opts.ServiceName != "" </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, ServiceNameKey, opts.ServiceName)
        }</span>

        <span class="cov7" title="4">return ctx</span>
}

// WithDefaultTimeout creates a new context with the default timeout
func WithDefaultTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov1" title="1">{
        return WithTimeout(ctx, DefaultTimeout, ContextOptions{Parent: ctx})
}</span>

// WithShortTimeout creates a new context with a short timeout
func WithShortTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov1" title="1">{
        return WithTimeout(ctx, ShortTimeout, ContextOptions{Parent: ctx})
}</span>

// WithLongTimeout creates a new context with a long timeout
func WithLongTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov1" title="1">{
        return WithTimeout(ctx, LongTimeout, ContextOptions{Parent: ctx})
}</span>

// WithDatabaseTimeout creates a new context with a database timeout
func WithDatabaseTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        return WithTimeout(ctx, DatabaseTimeout, ContextOptions{
                Parent:    ctx,
                Operation: "database",
        })
}</span>

// WithNetworkTimeout creates a new context with a network timeout
func WithNetworkTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        return WithTimeout(ctx, NetworkTimeout, ContextOptions{
                Parent:    ctx,
                Operation: "network",
        })
}</span>

// WithExternalServiceTimeout creates a new context with an external service timeout
func WithExternalServiceTimeout(ctx context.Context, serviceName string) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        return WithTimeout(ctx, ExternalServiceTimeout, ContextOptions{
                Parent:      ctx,
                Operation:   "external_service",
                ServiceName: serviceName,
        })
}</span>

// WithOperation creates a new context with an operation name
func WithOperation(ctx context.Context, operation string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, OperationKey, operation)
}</span>

// GetOperation gets the operation name from the context
func GetOperation(ctx context.Context) string <span class="cov4" title="2">{
        if op, ok := ctx.Value(OperationKey).(string); ok </span><span class="cov0" title="0">{
                return op
        }</span>
        <span class="cov4" title="2">return ""</span>
}

// WithCorrelationID adds a correlation ID to the context
func WithCorrelationID(ctx context.Context, correlationID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, CorrelationIDKey, correlationID)
}</span>

// GetCorrelationID gets the correlation ID from the context
func GetCorrelationID(ctx context.Context) string <span class="cov7" title="4">{
        if id, ok := ctx.Value(CorrelationIDKey).(string); ok </span><span class="cov0" title="0">{
                return id
        }</span>
        <span class="cov7" title="4">return ""</span>
}

// WithServiceName adds a service name to the context
func WithServiceName(ctx context.Context, serviceName string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ServiceNameKey, serviceName)
}</span>

// GetServiceName gets the service name from the context
func GetServiceName(ctx context.Context) string <span class="cov1" title="1">{
        if name, ok := ctx.Value(ServiceNameKey).(string); ok </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov1" title="1">return ""</span>
}

// CheckContext checks if the context is done and returns an appropriate error
func CheckContext(ctx context.Context) error <span class="cov6" title="3">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov4" title="2">
                err := ctx.Err()
                if err == context.DeadlineExceeded </span><span class="cov1" title="1">{
                        operation := GetOperation(ctx)
                        service := GetServiceName(ctx)
                        if operation != "" </span><span class="cov0" title="0">{
                                if service != "" </span><span class="cov0" title="0">{
                                        // Wrap ErrTimeout with additional context
                                        return fmt.Errorf("operation '%s' for service '%s' timed out: %w", operation, service, errors.ErrTimeout)
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("operation '%s' timed out: %w", operation, errors.ErrTimeout)</span>
                        }
                        <span class="cov1" title="1">return errors.ErrTimeout</span>
                }
                <span class="cov1" title="1">if err == context.Canceled </span><span class="cov1" title="1">{
                        operation := GetOperation(ctx)
                        if operation != "" </span><span class="cov0" title="0">{
                                // Wrap ErrCancelled with additional context
                                return fmt.Errorf("operation '%s' was canceled: %w", operation, errors.ErrCancelled)
                        }</span>
                        <span class="cov1" title="1">return errors.ErrCancelled</span>
                }
                <span class="cov0" title="0">return errors.Internal(err, "context error")</span>
        default:<span class="cov1" title="1">
                return nil</span>
        }
}

// MustCheck checks if the context is done and panics with an appropriate error if it is
func MustCheck(ctx context.Context) <span class="cov0" title="0">{
        if err := CheckContext(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// WithValues creates a new context with the specified key-value pairs
func WithValues(ctx context.Context, keyValues ...interface{}) context.Context <span class="cov4" title="2">{
        if len(keyValues)%2 != 0 </span><span class="cov1" title="1">{
                // If odd number of arguments, ignore the last one
                keyValues = keyValues[:len(keyValues)-1]
        }</span>

        <span class="cov4" title="2">for i := 0; i &lt; len(keyValues); i += 2 </span><span class="cov6" title="3">{
                ctx = context.WithValue(ctx, keyValues[i], keyValues[i+1])
        }</span>

        <span class="cov4" title="2">return ctx</span>
}

// Background returns a non-nil, empty Context. It is never canceled, has no
// values, and has no deadline.
func Background() context.Context <span class="cov1" title="1">{
        return context.Background()
}</span>

// TODO returns a non-nil, empty Context. Code should use context.TODO when
// it's unclear which Context to use or it is not yet available (because the
// surrounding function has not yet been extended to accept a Context parameter).
func TODO() context.Context <span class="cov1" title="1">{
        return context.TODO()
}</span>

// WithRequestID adds a request ID to the context
func WithRequestID(ctx context.Context) context.Context <span class="cov1" title="1">{
        return context.WithValue(ctx, RequestIDKey, uuid.New().String())
}</span>

// GetRequestID gets the request ID from the context
func GetRequestID(ctx context.Context) string <span class="cov10" title="6">{
        if id, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov1" title="1">{
                return id
        }</span>
        <span class="cov9" title="5">return ""</span>
}

// WithTraceID adds a trace ID to the context
func WithTraceID(ctx context.Context) context.Context <span class="cov1" title="1">{
        return context.WithValue(ctx, TraceIDKey, uuid.New().String())
}</span>

// GetTraceID gets the trace ID from the context
func GetTraceID(ctx context.Context) string <span class="cov10" title="6">{
        if id, ok := ctx.Value(TraceIDKey).(string); ok </span><span class="cov1" title="1">{
                return id
        }</span>
        <span class="cov9" title="5">return ""</span>
}

// WithUserID adds a user ID to the context
func WithUserID(ctx context.Context, userID string) context.Context <span class="cov1" title="1">{
        return context.WithValue(ctx, UserIDKey, userID)
}</span>

// GetUserID gets the user ID from the context
func GetUserID(ctx context.Context) string <span class="cov4" title="2">{
        if id, ok := ctx.Value(UserIDKey).(string); ok </span><span class="cov1" title="1">{
                return id
        }</span>
        <span class="cov1" title="1">return ""</span>
}

// WithTenantID adds a tenant ID to the context
func WithTenantID(ctx context.Context, tenantID string) context.Context <span class="cov1" title="1">{
        return context.WithValue(ctx, TenantIDKey, tenantID)
}</span>

// GetTenantID gets the tenant ID from the context
func GetTenantID(ctx context.Context) string <span class="cov4" title="2">{
        if id, ok := ctx.Value(TenantIDKey).(string); ok </span><span class="cov1" title="1">{
                return id
        }</span>
        <span class="cov1" title="1">return ""</span>
}

// ContextInfo returns a string with all the context information
func ContextInfo(ctx context.Context) string <span class="cov0" title="0">{
        info := fmt.Sprintf("RequestID: %s, TraceID: %s", GetRequestID(ctx), GetTraceID(ctx))

        if userID := GetUserID(ctx); userID != "" </span><span class="cov0" title="0">{
                info += fmt.Sprintf(", UserID: %s", userID)
        }</span>

        <span class="cov0" title="0">if tenantID := GetTenantID(ctx); tenantID != "" </span><span class="cov0" title="0">{
                info += fmt.Sprintf(", TenantID: %s", tenantID)
        }</span>

        <span class="cov0" title="0">if operation := GetOperation(ctx); operation != "" </span><span class="cov0" title="0">{
                info += fmt.Sprintf(", Operation: %s", operation)
        }</span>

        <span class="cov0" title="0">if correlationID := GetCorrelationID(ctx); correlationID != "" </span><span class="cov0" title="0">{
                info += fmt.Sprintf(", CorrelationID: %s", correlationID)
        }</span>

        <span class="cov0" title="0">if serviceName := GetServiceName(ctx); serviceName != "" </span><span class="cov0" title="0">{
                info += fmt.Sprintf(", ServiceName: %s", serviceName)
        }</span>

        <span class="cov0" title="0">deadline, ok := ctx.Deadline()
        if ok </span><span class="cov0" title="0">{
                info += fmt.Sprintf(", Deadline: %s", deadline.Format(time.RFC3339))
        }</span>

        <span class="cov0" title="0">return info</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package date provides utilities for working with dates and times.
package date

import (
        "time"

        "github.com/abitofhelp/servicelib/errors"
)

const (
        // StandardDateFormat is the standard date format used throughout the application
        StandardDateFormat = time.RFC3339
)

// ParseDate parses a date string in the standard format.
// Parameters:
//   - dateStr: The date string to parse
//
// Returns:
//   - time.Time: The parsed time
//   - error: An error if parsing fails
func ParseDate(dateStr string) (time.Time, error) <span class="cov8" title="3">{
        parsedDate, err := time.Parse(StandardDateFormat, dateStr)
        if err != nil </span><span class="cov5" title="2">{
                return time.Time{}, errors.NewValidationError("invalid date format")
        }</span>
        <span class="cov1" title="1">return parsedDate, nil</span>
}

// ParseOptionalDate parses an optional date string in the standard format.
// Parameters:
//   - dateStr: Pointer to the date string to parse, can be nil
//
// Returns:
//   - *time.Time: Pointer to the parsed time, nil if input is nil
//   - error: An error if parsing fails
func ParseOptionalDate(dateStr *string) (*time.Time, error) <span class="cov10" title="4">{
        if dateStr == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="3">parsedDate, err := time.Parse(StandardDateFormat, *dateStr)
        if err != nil </span><span class="cov5" title="2">{
                return nil, errors.NewValidationError("invalid date format")
        }</span>

        <span class="cov1" title="1">return &amp;parsedDate, nil</span>
}

// FormatDate formats a time.Time as a string in the standard format.
// Parameters:
//   - date: The time to format
//
// Returns:
//   - string: The formatted date string
func FormatDate(date time.Time) string <span class="cov5" title="2">{
        return date.Format(StandardDateFormat)
}</span>

// FormatOptionalDate formats an optional time.Time as a string in the standard format.
// Parameters:
//   - date: Pointer to the time to format, can be nil
//
// Returns:
//   - *string: Pointer to the formatted date string, nil if input is nil
func FormatOptionalDate(date *time.Time) *string <span class="cov8" title="3">{
        if date == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="2">formatted := date.Format(StandardDateFormat)
        return &amp;formatted</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package db provides utilities for working with databases.
package db

import (
        "context"
        "database/sql"
        "time"

        "github.com/abitofhelp/servicelib/logging"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/mattn/go-sqlite3" // SQLite driver
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// DefaultTimeout is the default timeout for database operations
const DefaultTimeout = 30 * time.Second

// InitMongoClient initializes a MongoDB client.
// Parameters:
//   - ctx: The context for the operation
//   - uri: The MongoDB connection URI
//   - timeout: The timeout for the connection operation
//
// Returns:
//   - *mongo.Client: The initialized MongoDB client
//   - error: An error if initialization fails
func InitMongoClient(ctx context.Context, uri string, timeout time.Duration) (*mongo.Client, error) <span class="cov8" title="1">{
        // Set up MongoDB client options
        clientOptions := options.Client().ApplyURI(uri)

        // Create a context with timeout for the connection
        connectCtx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Connect to MongoDB
        client, err := mongo.Connect(connectCtx, clientOptions)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Ping the database to verify connection
        <span class="cov0" title="0">if err := client.Ping(connectCtx, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// InitPostgresPool initializes a PostgreSQL connection pool.
// Parameters:
//   - ctx: The context for the operation
//   - uri: The PostgreSQL connection URI
//   - timeout: The timeout for the connection operation
//
// Returns:
//   - *pgxpool.Pool: The initialized PostgreSQL connection pool
//   - error: An error if initialization fails
func InitPostgresPool(ctx context.Context, uri string, timeout time.Duration) (*pgxpool.Pool, error) <span class="cov8" title="1">{
        // Create a context with timeout for the connection
        connectCtx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Connect to PostgreSQL
        pool, err := pgxpool.New(connectCtx, uri)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Ping the database to verify connection
        <span class="cov0" title="0">if err := pool.Ping(connectCtx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return pool, nil</span>
}

// InitSQLiteDB initializes a SQLite database connection.
// Parameters:
//   - ctx: The context for the operation
//   - uri: The SQLite connection URI
//   - timeout: The timeout for the connection operation
//   - maxOpenConns: The maximum number of open connections
//   - maxIdleConns: The maximum number of idle connections
//   - connMaxLifetime: The maximum lifetime of a connection
//
// Returns:
//   - *sql.DB: The initialized SQLite database connection
//   - error: An error if initialization fails
func InitSQLiteDB(ctx context.Context, uri string, timeout, connMaxLifetime time.Duration, maxOpenConns, maxIdleConns int) (*sql.DB, error) <span class="cov8" title="1">{
        // Create a context with timeout for the connection
        connectCtx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Connect to SQLite
        db, err := sql.Open("sqlite3", uri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set connection pool settings
        <span class="cov8" title="1">db.SetMaxOpenConns(maxOpenConns)
        db.SetMaxIdleConns(maxIdleConns)
        db.SetConnMaxLifetime(connMaxLifetime)

        // Ping the database to verify connection
        if err := db.PingContext(connectCtx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}

// LogDatabaseConnection logs a successful database connection.
// Parameters:
//   - ctx: The context for the operation
//   - logger: The logger to use
//   - dbType: The type of database (e.g., "MongoDB", "PostgreSQL", "SQLite")
func LogDatabaseConnection(ctx context.Context, logger *logging.ContextLogger, dbType string) <span class="cov8" title="1">{
        logger.Info(ctx, "Connected to "+dbType)
}</span>

// CheckPostgresHealth checks if a PostgreSQL connection is healthy.
// Parameters:
//   - ctx: The context for the operation
//   - pool: The PostgreSQL connection pool
//
// Returns:
//   - error: An error if the health check fails
func CheckPostgresHealth(ctx context.Context, pool *pgxpool.Pool) error <span class="cov0" title="0">{
        // Create a context with timeout for the health check
        healthCtx, cancel := context.WithTimeout(ctx, DefaultTimeout)
        defer cancel()

        // Ping the database to verify connection
        if err := pool.Ping(healthCtx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CheckMongoHealth checks if a MongoDB connection is healthy.
// Parameters:
//   - ctx: The context for the operation
//   - client: The MongoDB client
//
// Returns:
//   - error: An error if the health check fails
func CheckMongoHealth(ctx context.Context, client *mongo.Client) error <span class="cov0" title="0">{
        // Create a context with timeout for the health check
        healthCtx, cancel := context.WithTimeout(ctx, DefaultTimeout)
        defer cancel()

        // Ping the database to verify connection
        if err := client.Ping(healthCtx, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CheckSQLiteHealth checks if a SQLite connection is healthy.
// Parameters:
//   - ctx: The context for the operation
//   - db: The SQLite database connection
//
// Returns:
//   - error: An error if the health check fails
func CheckSQLiteHealth(ctx context.Context, db *sql.DB) error <span class="cov0" title="0">{
        // Create a context with timeout for the health check
        healthCtx, cancel := context.WithTimeout(ctx, DefaultTimeout)
        defer cancel()

        // Ping the database to verify connection
        if err := db.PingContext(healthCtx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExecutePostgresTransaction executes a function within a PostgreSQL transaction.
// Parameters:
//   - ctx: The context for the operation
//   - pool: The PostgreSQL connection pool
//   - fn: The function to execute within the transaction
//
// Returns:
//   - error: An error if the transaction fails
func ExecutePostgresTransaction(ctx context.Context, pool *pgxpool.Pool, fn func(tx pgx.Tx) error) error <span class="cov0" title="0">{
        // Create a context with timeout for the transaction
        txCtx, cancel := context.WithTimeout(ctx, DefaultTimeout)
        defer cancel()

        // Begin transaction
        tx, err := pool.Begin(txCtx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure transaction is rolled back if not committed
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tx != nil </span><span class="cov0" title="0">{
                        tx.Rollback(context.Background())
                }</span>
        }()

        // Execute function
        <span class="cov0" title="0">if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit(txCtx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExecuteSQLTransaction executes a function within a SQL transaction.
// Parameters:
//   - ctx: The context for the operation
//   - db: The SQL database connection
//   - fn: The function to execute within the transaction
//
// Returns:
//   - error: An error if the transaction fails
func ExecuteSQLTransaction(ctx context.Context, db *sql.DB, fn func(tx *sql.Tx) error) error <span class="cov0" title="0">{
        // Create a context with timeout for the transaction
        txCtx, cancel := context.WithTimeout(ctx, DefaultTimeout)
        defer cancel()

        // Begin transaction
        tx, err := db.BeginTx(txCtx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure transaction is rolled back if not committed
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tx != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Execute function
        <span class="cov0" title="0">if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/abitofhelp/family-service/pkg/db (interfaces: SQLDBInterface,SQLTxInterface,MongoClientInterface,PgxPoolInterface,PgxTxInterface)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        sql "database/sql"
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
        pgx "github.com/jackc/pgx/v5"
        mongo "go.mongodb.org/mongo-driver/mongo"
        options "go.mongodb.org/mongo-driver/mongo/options"
        readpref "go.mongodb.org/mongo-driver/mongo/readpref"
)

// MockSQLDBInterface is a mock of SQLDBInterface interface.
type MockSQLDBInterface struct {
        ctrl     *gomock.Controller
        recorder *MockSQLDBInterfaceMockRecorder
}

// MockSQLDBInterfaceMockRecorder is the mock recorder for MockSQLDBInterface.
type MockSQLDBInterfaceMockRecorder struct {
        mock *MockSQLDBInterface
}

// NewMockSQLDBInterface creates a new mock instance.
func NewMockSQLDBInterface(ctrl *gomock.Controller) *MockSQLDBInterface <span class="cov0" title="0">{
        mock := &amp;MockSQLDBInterface{ctrl: ctrl}
        mock.recorder = &amp;MockSQLDBInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSQLDBInterface) EXPECT() *MockSQLDBInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// BeginTx mocks base method.
func (m *MockSQLDBInterface) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BeginTx", ctx, opts)
        ret0, _ := ret[0].(*sql.Tx)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// BeginTx indicates an expected call of BeginTx.
func (mr *MockSQLDBInterfaceMockRecorder) BeginTx(ctx, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockSQLDBInterface)(nil).BeginTx), ctx, opts)
}</span>

// PingContext mocks base method.
func (m *MockSQLDBInterface) PingContext(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PingContext", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PingContext indicates an expected call of PingContext.
func (mr *MockSQLDBInterfaceMockRecorder) PingContext(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PingContext", reflect.TypeOf((*MockSQLDBInterface)(nil).PingContext), ctx)
}</span>

// SetConnMaxLifetime mocks base method.
func (m *MockSQLDBInterface) SetConnMaxLifetime(d time.Duration) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SetConnMaxLifetime", d)
}</span>

// SetConnMaxLifetime indicates an expected call of SetConnMaxLifetime.
func (mr *MockSQLDBInterfaceMockRecorder) SetConnMaxLifetime(d interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetConnMaxLifetime", reflect.TypeOf((*MockSQLDBInterface)(nil).SetConnMaxLifetime), d)
}</span>

// SetMaxIdleConns mocks base method.
func (m *MockSQLDBInterface) SetMaxIdleConns(n int) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SetMaxIdleConns", n)
}</span>

// SetMaxIdleConns indicates an expected call of SetMaxIdleConns.
func (mr *MockSQLDBInterfaceMockRecorder) SetMaxIdleConns(n interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMaxIdleConns", reflect.TypeOf((*MockSQLDBInterface)(nil).SetMaxIdleConns), n)
}</span>

// SetMaxOpenConns mocks base method.
func (m *MockSQLDBInterface) SetMaxOpenConns(n int) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SetMaxOpenConns", n)
}</span>

// SetMaxOpenConns indicates an expected call of SetMaxOpenConns.
func (mr *MockSQLDBInterfaceMockRecorder) SetMaxOpenConns(n interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMaxOpenConns", reflect.TypeOf((*MockSQLDBInterface)(nil).SetMaxOpenConns), n)
}</span>

// MockSQLTxInterface is a mock of SQLTxInterface interface.
type MockSQLTxInterface struct {
        ctrl     *gomock.Controller
        recorder *MockSQLTxInterfaceMockRecorder
}

// MockSQLTxInterfaceMockRecorder is the mock recorder for MockSQLTxInterface.
type MockSQLTxInterfaceMockRecorder struct {
        mock *MockSQLTxInterface
}

// NewMockSQLTxInterface creates a new mock instance.
func NewMockSQLTxInterface(ctrl *gomock.Controller) *MockSQLTxInterface <span class="cov0" title="0">{
        mock := &amp;MockSQLTxInterface{ctrl: ctrl}
        mock.recorder = &amp;MockSQLTxInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSQLTxInterface) EXPECT() *MockSQLTxInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Commit mocks base method.
func (m *MockSQLTxInterface) Commit() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Commit")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Commit indicates an expected call of Commit.
func (mr *MockSQLTxInterfaceMockRecorder) Commit() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockSQLTxInterface)(nil).Commit))
}</span>

// Rollback mocks base method.
func (m *MockSQLTxInterface) Rollback() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Rollback")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Rollback indicates an expected call of Rollback.
func (mr *MockSQLTxInterfaceMockRecorder) Rollback() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockSQLTxInterface)(nil).Rollback))
}</span>

// MockMongoClientInterface is a mock of MongoClientInterface interface.
type MockMongoClientInterface struct {
        ctrl     *gomock.Controller
        recorder *MockMongoClientInterfaceMockRecorder
}

// MockMongoClientInterfaceMockRecorder is the mock recorder for MockMongoClientInterface.
type MockMongoClientInterfaceMockRecorder struct {
        mock *MockMongoClientInterface
}

// NewMockMongoClientInterface creates a new mock instance.
func NewMockMongoClientInterface(ctrl *gomock.Controller) *MockMongoClientInterface <span class="cov0" title="0">{
        mock := &amp;MockMongoClientInterface{ctrl: ctrl}
        mock.recorder = &amp;MockMongoClientInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMongoClientInterface) EXPECT() *MockMongoClientInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Connect mocks base method.
func (m *MockMongoClientInterface) Connect(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Connect", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Connect indicates an expected call of Connect.
func (mr *MockMongoClientInterfaceMockRecorder) Connect(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockMongoClientInterface)(nil).Connect), ctx)
}</span>

// Database mocks base method.
func (m *MockMongoClientInterface) Database(name string, opts ...*options.DatabaseOptions) *mongo.Database <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{name}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Database", varargs...)
        ret0, _ := ret[0].(*mongo.Database)
        return ret0</span>
}

// Database indicates an expected call of Database.
func (mr *MockMongoClientInterfaceMockRecorder) Database(name interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{name}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Database", reflect.TypeOf((*MockMongoClientInterface)(nil).Database), varargs...)
}</span>

// Ping mocks base method.
func (m *MockMongoClientInterface) Ping(ctx context.Context, rp *readpref.ReadPref) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", ctx, rp)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockMongoClientInterfaceMockRecorder) Ping(ctx, rp interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockMongoClientInterface)(nil).Ping), ctx, rp)
}</span>

// MockPgxPoolInterface is a mock of PgxPoolInterface interface.
type MockPgxPoolInterface struct {
        ctrl     *gomock.Controller
        recorder *MockPgxPoolInterfaceMockRecorder
}

// MockPgxPoolInterfaceMockRecorder is the mock recorder for MockPgxPoolInterface.
type MockPgxPoolInterfaceMockRecorder struct {
        mock *MockPgxPoolInterface
}

// NewMockPgxPoolInterface creates a new mock instance.
func NewMockPgxPoolInterface(ctrl *gomock.Controller) *MockPgxPoolInterface <span class="cov0" title="0">{
        mock := &amp;MockPgxPoolInterface{ctrl: ctrl}
        mock.recorder = &amp;MockPgxPoolInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPgxPoolInterface) EXPECT() *MockPgxPoolInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Begin mocks base method.
func (m *MockPgxPoolInterface) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Begin", ctx)
        ret0, _ := ret[0].(pgx.Tx)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Begin indicates an expected call of Begin.
func (mr *MockPgxPoolInterfaceMockRecorder) Begin(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockPgxPoolInterface)(nil).Begin), ctx)
}</span>

// Close mocks base method.
func (m *MockPgxPoolInterface) Close() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Close")
}</span>

// Close indicates an expected call of Close.
func (mr *MockPgxPoolInterfaceMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockPgxPoolInterface)(nil).Close))
}</span>

// Ping mocks base method.
func (m *MockPgxPoolInterface) Ping(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockPgxPoolInterfaceMockRecorder) Ping(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockPgxPoolInterface)(nil).Ping), ctx)
}</span>

// MockPgxTxInterface is a mock of PgxTxInterface interface.
type MockPgxTxInterface struct {
        ctrl     *gomock.Controller
        recorder *MockPgxTxInterfaceMockRecorder
}

// MockPgxTxInterfaceMockRecorder is the mock recorder for MockPgxTxInterface.
type MockPgxTxInterfaceMockRecorder struct {
        mock *MockPgxTxInterface
}

// NewMockPgxTxInterface creates a new mock instance.
func NewMockPgxTxInterface(ctrl *gomock.Controller) *MockPgxTxInterface <span class="cov0" title="0">{
        mock := &amp;MockPgxTxInterface{ctrl: ctrl}
        mock.recorder = &amp;MockPgxTxInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPgxTxInterface) EXPECT() *MockPgxTxInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Commit mocks base method.
func (m *MockPgxTxInterface) Commit(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Commit", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Commit indicates an expected call of Commit.
func (mr *MockPgxTxInterfaceMockRecorder) Commit(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockPgxTxInterface)(nil).Commit), ctx)
}</span>

// Rollback mocks base method.
func (m *MockPgxTxInterface) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Rollback", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Rollback indicates an expected call of Rollback.
func (mr *MockPgxTxInterfaceMockRecorder) Rollback(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockPgxTxInterface)(nil).Rollback), ctx)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides a generic dependency injection container that can be used across different applications.
package di

import (
        "context"
        "fmt"

        "github.com/abitofhelp/servicelib/logging"
        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"
)

// BaseContainer is a generic dependency injection container that can be embedded in other containers
type BaseContainer[C any] struct {
        ctx           context.Context
        logger        *zap.Logger
        contextLogger *logging.ContextLogger
        validator     *validator.Validate
        config        C
}

// NewBaseContainer creates a new base dependency injection container
func NewBaseContainer[C any](ctx context.Context, logger *zap.Logger, cfg C) (*BaseContainer[C], error) <span class="cov10" title="9">{
        if ctx == nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("context cannot be nil")
        }</span>
        <span class="cov8" title="7">if logger == nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>

        <span class="cov7" title="5">container := &amp;BaseContainer[C]{
                ctx:    ctx,
                logger: logger,
                config: cfg,
        }

        // Initialize context logger
        container.contextLogger = logging.NewContextLogger(logger)

        // Initialize validator
        container.validator = validator.New()

        return container, nil</span>
}

// GetContext returns the context
func (c *BaseContainer[C]) GetContext() context.Context <span class="cov3" title="2">{
        return c.ctx
}</span>

// GetLogger returns the logger
func (c *BaseContainer[C]) GetLogger() *zap.Logger <span class="cov3" title="2">{
        return c.logger
}</span>

// GetContextLogger returns the context logger
func (c *BaseContainer[C]) GetContextLogger() *logging.ContextLogger <span class="cov3" title="2">{
        return c.contextLogger
}</span>

// GetValidator returns the validator
func (c *BaseContainer[C]) GetValidator() *validator.Validate <span class="cov3" title="2">{
        return c.validator
}</span>

// GetConfig returns the configuration
func (c *BaseContainer[C]) GetConfig() C <span class="cov5" title="3">{
        return c.config
}</span>

// Close closes all resources
func (c *BaseContainer[C]) Close() error <span class="cov1" title="1">{
        // Base container has no resources to close
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides a generic dependency injection container that can be used across different applications.
package di

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"
)

// Default timeout for database operations
const DefaultTimeout = 30 * time.Second

// Container is a generic dependency injection container for backward compatibility
// It uses the BaseContainer with an interface{} config type
type Container struct {
        *BaseContainer[interface{}]
}

// NewContainer creates a new generic dependency injection container
// This function is kept for backward compatibility
func NewContainer(ctx context.Context, logger *zap.Logger, cfg interface{}) (*Container, error) <span class="cov10" title="5">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>

        <span class="cov8" title="4">baseContainer, err := NewBaseContainer(ctx, logger, cfg)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;Container{
                BaseContainer: baseContainer,
        }, nil</span>
}

// GetRepositoryFactory returns the repository factory
// This is a placeholder method that should be overridden by derived containers
func (c *Container) GetRepositoryFactory() interface{} <span class="cov1" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides generic database initializers that can be used across different applications.
package di

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/abitofhelp/servicelib/db"
        "github.com/abitofhelp/servicelib/logging"
        "github.com/jackc/pgx/v5/pgxpool"
        "go.mongodb.org/mongo-driver/mongo"
        "go.uber.org/zap"
)

// MongoDBInitializer initializes a MongoDB client and collection
func MongoDBInitializer(
        ctx context.Context,
        uri string,
        databaseName string,
        collectionName string,
        logger *zap.Logger,
) (*mongo.Collection, error) <span class="cov0" title="0">{
        // Create a context logger
        contextLogger := logging.NewContextLogger(logger)

        // Initialize MongoDB client using the db package
        client, err := db.InitMongoClient(ctx, uri, DefaultTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize MongoDB client: %w", err)
        }</span>

        // Log successful connection
        <span class="cov0" title="0">db.LogDatabaseConnection(ctx, contextLogger, "MongoDB")

        // Get the collection
        collection := client.Database(databaseName).Collection(collectionName)

        return collection, nil</span>
}

// PostgresInitializer initializes a PostgreSQL connection pool
func PostgresInitializer(
        ctx context.Context,
        dsn string,
        logger *zap.Logger,
) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        // Create a context logger
        contextLogger := logging.NewContextLogger(logger)

        // Initialize PostgreSQL connection pool using the db package
        pool, err := db.InitPostgresPool(ctx, dsn, DefaultTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize PostgreSQL connection pool: %w", err)
        }</span>

        // Log successful connection
        <span class="cov0" title="0">db.LogDatabaseConnection(ctx, contextLogger, "PostgreSQL")

        return pool, nil</span>
}

// SQLiteInitializer initializes a SQLite database connection
func SQLiteInitializer(
        ctx context.Context,
        uri string,
        logger *zap.Logger,
) (*sql.DB, error) <span class="cov0" title="0">{
        // Create a context logger
        contextLogger := logging.NewContextLogger(logger)

        // Initialize SQLite database connection using the db package
        sqliteDB, err := db.InitSQLiteDB(ctx, uri, DefaultTimeout, time.Hour, 10, 5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize SQLite database connection: %w", err)
        }</span>

        // Log successful connection
        <span class="cov0" title="0">db.LogDatabaseConnection(ctx, contextLogger, "SQLite")

        return sqliteDB, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides a generic dependency injection container that can be used across different applications.
package di

import (
        "context"
        "fmt"

        "go.uber.org/zap"
)

// AppRepositoryInitializer is a function type that initializes a repository
type AppRepositoryInitializer[T any] func(ctx context.Context, connectionString string, logger *zap.Logger) (T, error)

// GenericDomainServiceInitializer is a function type that initializes a domain service
type GenericDomainServiceInitializer[R any, D any] func(repository R) (D, error)

// GenericApplicationServiceInitializer is a function type that initializes an application service
type GenericApplicationServiceInitializer[R any, D any, A any] func(domainService D, repository R) (A, error)

// GenericAppContainer is a generic dependency injection container for any application
type GenericAppContainer[R any, D any, A any, C any] struct {
        *BaseContainer[C]
        repository         R
        domainService      D
        applicationService A
}

// NewGenericAppContainer creates a new generic application container
func NewGenericAppContainer[R any, D any, A any, C any](
        ctx context.Context,
        logger *zap.Logger,
        cfg C,
        connectionString string,
        initRepo AppRepositoryInitializer[R],
        initDomainService GenericDomainServiceInitializer[R, D],
        initAppService GenericApplicationServiceInitializer[R, D, A],
) (*GenericAppContainer[R, D, A, C], error) <span class="cov0" title="0">{
        // Create base container
        baseContainer, err := NewBaseContainer(ctx, logger, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create base container: %w", err)
        }</span>

        // Create generic container
        <span class="cov0" title="0">container := &amp;GenericAppContainer[R, D, A, C]{
                BaseContainer: baseContainer,
        }

        // Initialize repository
        container.repository, err = initRepo(ctx, connectionString, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize repository: %w", err)
        }</span>

        // Initialize domain service
        <span class="cov0" title="0">container.domainService, err = initDomainService(container.repository)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize domain service: %w", err)
        }</span>

        // Initialize application service
        <span class="cov0" title="0">container.applicationService, err = initAppService(container.domainService, container.repository)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize application service: %w", err)
        }</span>

        <span class="cov0" title="0">return container, nil</span>
}

// GetRepository returns the repository
func (c *GenericAppContainer[R, D, A, C]) GetRepository() R <span class="cov0" title="0">{
        return c.repository
}</span>

// GetDomainService returns the domain service
func (c *GenericAppContainer[R, D, A, C]) GetDomainService() D <span class="cov0" title="0">{
        return c.domainService
}</span>

// GetApplicationService returns the application service
func (c *GenericAppContainer[R, D, A, C]) GetApplicationService() A <span class="cov0" title="0">{
        return c.applicationService
}</span>

// GetRepositoryFactory returns the repository as an interface{}
func (c *GenericAppContainer[R, D, A, C]) GetRepositoryFactory() interface{} <span class="cov0" title="0">{
        return c.repository
}</span>

// Close closes all resources
func (c *GenericAppContainer[R, D, A, C]) Close() error <span class="cov0" title="0">{
        var errs []error

        // Add resource cleanup here as needed
        // For example, close database connections if they implement a Close method

        // Close base container
        if err := c.BaseContainer.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        // Return a combined error if any occurred
        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                errMsg := "failed to close one or more resources:"
                for _, err := range errs </span><span class="cov0" title="0">{
                        errMsg += " " + err.Error()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%s", errMsg)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides a generic dependency injection container that can be used across different applications.
package di

import (
        "context"
        "fmt"

        pkgconfig "github.com/abitofhelp/servicelib/config"
        "go.uber.org/zap"
)

// GenericRepositoryInitializer is a function type that initializes a repository
type GenericRepositoryInitializer[T any] func(ctx context.Context, connectionString string, logger *zap.Logger) (T, error)

// GenericRepositoryContainer is a generic dependency injection container for any repository type
type GenericRepositoryContainer[T any, C any] struct {
        *BaseContainer[C]
        config     pkgconfig.Config
        repository T
}

// NewGenericRepositoryContainer creates a new generic repository container
func NewGenericRepositoryContainer[T any, C any](
        ctx context.Context,
        logger *zap.Logger,
        cfg C,
        entityType string,
        initRepo GenericRepositoryInitializer[T],
) (*GenericRepositoryContainer[T, C], error) <span class="cov0" title="0">{
        // Create base container
        baseContainer, err := NewBaseContainer(ctx, logger, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create base container: %w", err)
        }</span>

        // Create a config adapter
        <span class="cov0" title="0">configAdapter := pkgconfig.NewGenericConfigAdapter(cfg)

        // Create generic container
        container := &amp;GenericRepositoryContainer[T, C]{
                BaseContainer: baseContainer,
                config:        configAdapter,
        }

        // Get database configuration
        dbConfig := configAdapter.GetDatabase()
        connectionString := dbConfig.GetConnectionString()

        // Initialize repository
        container.repository, err = initRepo(ctx, connectionString, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize repository: %w", err)
        }</span>

        <span class="cov0" title="0">return container, nil</span>
}

// GetRepository returns the repository
func (c *GenericRepositoryContainer[T, C]) GetRepository() T <span class="cov0" title="0">{
        return c.repository
}</span>

// GetRepositoryFactory returns the repository as an interface{}
func (c *GenericRepositoryContainer[T, C]) GetRepositoryFactory() interface{} <span class="cov0" title="0">{
        return c.repository
}</span>

// Close closes all resources
func (c *GenericRepositoryContainer[T, C]) Close() error <span class="cov0" title="0">{
        var errs []error

        // Add resource cleanup here as needed
        // For example, close database connections if they implement a Close method

        // Close base container
        if err := c.BaseContainer.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        // Return a combined error if any occurred
        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                errMsg := "failed to close one or more resources:"
                for _, err := range errs </span><span class="cov0" title="0">{
                        errMsg += " " + err.Error()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%s", errMsg)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides a generic dependency injection container that can be used across different applications.
package di

import (
        "context"
        "fmt"

        "github.com/abitofhelp/servicelib/config"
        "go.uber.org/zap"
)

// RepositoryInitializerFunc is a function type that initializes a repository
type RepositoryInitializerFunc[T any] func(
        ctx context.Context, 
        connectionString string, 
        databaseName string, 
        collectionName string, 
        logger *zap.Logger,
) (T, error)

// RepositoryContainer is a generic dependency injection container for any repository type
type RepositoryContainer[T any] struct {
        ctx        context.Context
        logger     *zap.Logger
        config     config.Config
        repository T
}

// NewRepositoryContainer creates a new repository container
func NewRepositoryContainer[T any](
        ctx context.Context,
        logger *zap.Logger,
        cfg config.Config,
        entityType string,
        initRepo RepositoryInitializerFunc[T],
) (*RepositoryContainer[T], error) <span class="cov10" title="6">{
        if ctx == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("context cannot be nil")
        }</span>
        <span class="cov9" title="5">if logger == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>
        <span class="cov7" title="4">if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>

        // Create container
        <span class="cov6" title="3">container := &amp;RepositoryContainer[T]{
                ctx:    ctx,
                logger: logger,
                config: cfg,
        }

        // Get database configuration
        dbConfig := cfg.GetDatabase()
        connectionString := dbConfig.GetConnectionString()
        databaseName := dbConfig.GetDatabaseName()
        collectionName := dbConfig.GetCollectionName(entityType)

        // Initialize repository
        var err error
        container.repository, err = initRepo(ctx, connectionString, databaseName, collectionName, logger)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to initialize repository: %w", err)
        }</span>

        <span class="cov4" title="2">return container, nil</span>
}

// GetContext returns the context
func (c *RepositoryContainer[T]) GetContext() context.Context <span class="cov1" title="1">{
        return c.ctx
}</span>

// GetLogger returns the logger
func (c *RepositoryContainer[T]) GetLogger() *zap.Logger <span class="cov1" title="1">{
        return c.logger
}</span>

// GetConfig returns the configuration
func (c *RepositoryContainer[T]) GetConfig() config.Config <span class="cov1" title="1">{
        return c.config
}</span>

// GetRepository returns the repository
func (c *RepositoryContainer[T]) GetRepository() T <span class="cov6" title="3">{
        return c.repository
}</span>

// GetRepositoryFactory returns the repository as an interface{}
func (c *RepositoryContainer[T]) GetRepositoryFactory() interface{} <span class="cov1" title="1">{
        return c.repository
}</span>

// Close closes all resources
func (c *RepositoryContainer[T]) Close() error <span class="cov1" title="1">{
        // No resources to close in this implementation
        return nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides repository initializers for different database types.
package di

import (
        "context"
        "fmt"
        "time"

        "github.com/abitofhelp/servicelib/db"
        "github.com/abitofhelp/servicelib/logging"
        "go.uber.org/zap"
)

// GenericMongoInitializer initializes a MongoDB collection and returns it
// This can be used by applications to create their own repository initializers
func GenericMongoInitializer(
        ctx context.Context, 
        uri string, 
        databaseName string,
        collectionName string,
        zapLogger *zap.Logger,
) (interface{}, error) <span class="cov0" title="0">{
        // Create a context logger
        logger := logging.NewContextLogger(zapLogger)

        // Initialize MongoDB client using the db package
        client, err := db.InitMongoClient(ctx, uri, DefaultTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize MongoDB client: %w", err)
        }</span>

        // Log successful connection
        <span class="cov0" title="0">db.LogDatabaseConnection(ctx, logger, "MongoDB")

        // Get the collection
        collection := client.Database(databaseName).Collection(collectionName)

        return collection, nil</span>
}

// GenericPostgresInitializer initializes a PostgreSQL connection pool and returns it
// This can be used by applications to create their own repository initializers
func GenericPostgresInitializer(
        ctx context.Context, 
        dsn string, 
        zapLogger *zap.Logger,
) (interface{}, error) <span class="cov0" title="0">{
        // Create a context logger
        logger := logging.NewContextLogger(zapLogger)

        // Initialize PostgreSQL connection pool using the db package
        pool, err := db.InitPostgresPool(ctx, dsn, DefaultTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize PostgreSQL connection pool: %w", err)
        }</span>

        // Log successful connection
        <span class="cov0" title="0">db.LogDatabaseConnection(ctx, logger, "PostgreSQL")

        return pool, nil</span>
}

// GenericSQLiteInitializer initializes a SQLite database connection and returns it
// This can be used by applications to create their own repository initializers
func GenericSQLiteInitializer(
        ctx context.Context, 
        uri string, 
        zapLogger *zap.Logger,
) (interface{}, error) <span class="cov0" title="0">{
        // Create a context logger
        logger := logging.NewContextLogger(zapLogger)

        // Initialize SQLite database connection using the db package
        sqliteDB, err := db.InitSQLiteDB(ctx, uri, DefaultTimeout, time.Hour, 10, 5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize SQLite database connection: %w", err)
        }</span>

        // Log successful connection
        <span class="cov0" title="0">db.LogDatabaseConnection(ctx, logger, "SQLite")

        return sqliteDB, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package di provides a generic dependency injection container that can be used across different applications.
package di

import (
        "context"
        "fmt"

        "github.com/abitofhelp/servicelib/config"
        "go.uber.org/zap"
)

// ServiceContainer is a generic dependency injection container for services
type ServiceContainer[R Repository, D DomainService, A ApplicationService, C config.Config] struct {
        *BaseContainer[C]
        repository         R
        domainService      D
        applicationService A
}

// DomainServiceInitializerFunc is a function type that initializes a domain service
type DomainServiceInitializerFunc[R Repository, D DomainService] func(repository R) (D, error)

// ApplicationServiceInitializerFunc is a function type that initializes an application service
type ApplicationServiceInitializerFunc[R Repository, D DomainService, A ApplicationService] func(
        domainService D,
        repository R,
) (A, error)

// NewServiceContainer creates a new service container
func NewServiceContainer[R Repository, D DomainService, A ApplicationService, C config.Config](
        ctx context.Context,
        logger *zap.Logger,
        cfg C,
        repository R,
        initDomainService DomainServiceInitializerFunc[R, D],
        initAppService ApplicationServiceInitializerFunc[R, D, A],
) (*ServiceContainer[R, D, A, C], error) <span class="cov0" title="0">{
        // Create base container
        baseContainer, err := NewBaseContainer(ctx, logger, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create base container: %w", err)
        }</span>

        // Create service container
        <span class="cov0" title="0">container := &amp;ServiceContainer[R, D, A, C]{
                BaseContainer: baseContainer,
                repository:    repository,
        }

        // Initialize domain service
        container.domainService, err = initDomainService(repository)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize domain service: %w", err)
        }</span>

        // Initialize application service
        <span class="cov0" title="0">container.applicationService, err = initAppService(container.domainService, repository)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize application service: %w", err)
        }</span>

        <span class="cov0" title="0">return container, nil</span>
}

// GetRepository returns the repository
func (c *ServiceContainer[R, D, A, C]) GetRepository() R <span class="cov0" title="0">{
        return c.repository
}</span>

// GetDomainService returns the domain service
func (c *ServiceContainer[R, D, A, C]) GetDomainService() D <span class="cov0" title="0">{
        return c.domainService
}</span>

// GetApplicationService returns the application service
func (c *ServiceContainer[R, D, A, C]) GetApplicationService() A <span class="cov0" title="0">{
        return c.applicationService
}</span>

// GetRepositoryFactory returns the repository as an interface{}
func (c *ServiceContainer[R, D, A, C]) GetRepositoryFactory() interface{} <span class="cov0" title="0">{
        return c.repository
}</span>

// Close closes all resources
func (c *ServiceContainer[R, D, A, C]) Close() error <span class="cov0" title="0">{
        // Close base container
        return c.BaseContainer.Close()
}</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package env provides utilities for working with environment variables.
package env

import "os"

// GetEnv retrieves the value of the environment variable named by the key.
// If the variable is not present, the fallback value is returned.
// Parameters:
//   - key: The name of the environment variable
//   - fallback: The value to return if the environment variable is not set
//
// Returns:
//   - string: The value of the environment variable or the fallback value
func GetEnv(key, fallback string) string <span class="cov10" title="3">{
        if value, ok := os.LookupEnv(key); ok </span><span class="cov6" title="2">{
                return value
        }</span>
        <span class="cov1" title="1">return fallback</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package errors provides a comprehensive error handling system for the application.
// It includes error codes, HTTP status mapping, contextual information, and utilities
// for creating, wrapping, and serializing errors.
package errors

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "path/filepath"
        "runtime"
        "strings"
)

// ErrorCode represents a unique error code for categorizing errors.
// These codes are used for error identification, logging, and mapping to HTTP status codes.
type ErrorCode string

// Standard error codes define all possible error categories in the application.
const (
        // NotFoundCode is used when a resource is not found.
        // Maps to HTTP 404 Not Found.
        NotFoundCode ErrorCode = "NOT_FOUND"

        // InvalidInputCode is used when input validation fails.
        // Maps to HTTP 400 Bad Request.
        InvalidInputCode ErrorCode = "INVALID_INPUT"

        // DatabaseErrorCode is used for database operation failures.
        // Maps to HTTP 500 Internal Server Error.
        DatabaseErrorCode ErrorCode = "DATABASE_ERROR"

        // InternalErrorCode is used for internal server errors.
        // Maps to HTTP 500 Internal Server Error.
        InternalErrorCode ErrorCode = "INTERNAL_ERROR"

        // TimeoutCode is used when an operation times out.
        // Maps to HTTP 504 Gateway Timeout.
        TimeoutCode ErrorCode = "TIMEOUT"

        // CanceledCode is used when an operation is canceled.
        // Maps to HTTP 408 Request Timeout.
        CanceledCode ErrorCode = "CANCELED"

        // AlreadyExistsCode is used when a resource already exists.
        // Maps to HTTP 409 Conflict.
        AlreadyExistsCode ErrorCode = "ALREADY_EXISTS"

        // UnauthorizedCode is used for authentication failures.
        // Maps to HTTP 401 Unauthorized.
        UnauthorizedCode ErrorCode = "UNAUTHORIZED"

        // ForbiddenCode is used for authorization failures.
        // Maps to HTTP 403 Forbidden.
        ForbiddenCode ErrorCode = "FORBIDDEN"

        // ValidationErrorCode is used for domain validation errors.
        // Maps to HTTP 400 Bad Request.
        ValidationErrorCode ErrorCode = "VALIDATION_ERROR"

        // BusinessRuleViolationCode is used when a business rule is violated.
        // Maps to HTTP 422 Unprocessable Entity.
        BusinessRuleViolationCode ErrorCode = "BUSINESS_RULE_VIOLATION"

        // ExternalServiceErrorCode is used when an external service call fails.
        // Maps to HTTP 502 Bad Gateway.
        ExternalServiceErrorCode ErrorCode = "EXTERNAL_SERVICE_ERROR"

        // NetworkErrorCode is used for network-related errors.
        // Maps to HTTP 503 Service Unavailable.
        NetworkErrorCode ErrorCode = "NETWORK_ERROR"

        // ConfigurationErrorCode is used for configuration errors.
        // Maps to HTTP 500 Internal Server Error.
        ConfigurationErrorCode ErrorCode = "CONFIGURATION_ERROR"

        // ResourceExhaustedCode is used when a resource limit is reached.
        // Maps to HTTP 429 Too Many Requests.
        ResourceExhaustedCode ErrorCode = "RESOURCE_EXHAUSTED"

        // DataCorruptionCode is used when data is corrupted.
        // Maps to HTTP 500 Internal Server Error.
        DataCorruptionCode ErrorCode = "DATA_CORRUPTION"

        // ConcurrencyErrorCode is used for concurrency-related errors.
        // Maps to HTTP 409 Conflict.
        ConcurrencyErrorCode ErrorCode = "CONCURRENCY_ERROR"
)

// Standard errors that can be used throughout the application
var (
        // ErrNotFound is returned when a requested resource is not found
        ErrNotFound = errors.New("resource not found")

        // ErrAlreadyExists is returned when a resource already exists
        ErrAlreadyExists = errors.New("resource already exists")

        // ErrInvalidInput is returned when the input to a function is invalid
        ErrInvalidInput = errors.New("invalid input")

        // ErrInternal is returned when an internal error occurs
        ErrInternal = errors.New("internal error")

        // ErrUnauthorized is returned when a user is not authorized to perform an action
        ErrUnauthorized = errors.New("unauthorized")

        // ErrForbidden is returned when a user is forbidden from performing an action
        ErrForbidden = errors.New("forbidden")

        // ErrTimeout is returned when an operation times out
        ErrTimeout = errors.New("operation timed out")

        // ErrCancelled is returned when an operation is cancelled
        ErrCancelled = errors.New("operation cancelled")

        // ErrConflict is returned when there is a conflict with the current state
        ErrConflict = errors.New("conflict with current state")
)

// ErrorContext holds additional context for an error.
// It includes information about the operation that failed, the source location,
// and any additional details that might be useful for debugging or error reporting.
type ErrorContext struct {
        // Operation is the name of the operation that failed
        Operation string `json:"operation,omitempty"`

        // Source is the file and line where the error occurred
        Source string `json:"source,omitempty"`

        // Line is the line number where the error occurred
        Line int `json:"line,omitempty"`

        // Code is the error code
        Code ErrorCode `json:"code,omitempty"`

        // HTTPStatus is the HTTP status code to return for this error
        HTTPStatus int `json:"http_status,omitempty"`

        // Details contains additional information about the error
        Details map[string]interface{} `json:"details,omitempty"`
}

// ContextualError is an error with additional context.
// It wraps another error and adds contextual information like operation name,
// error code, HTTP status, and source location.
type ContextualError struct {
        // Original is the original error that was wrapped
        Original error

        // Context contains additional information about the error
        Context ErrorContext
}

// Error returns the error message with contextual information.
func (e *ContextualError) Error() string <span class="cov9" title="24">{
        var builder strings.Builder

        // Add operation if available
        if e.Context.Operation != "" </span><span class="cov6" title="8">{
                builder.WriteString(fmt.Sprintf("operation %s: ", e.Context.Operation))
        }</span>

        // Add original error message
        <span class="cov9" title="24">if e.Original != nil </span><span class="cov9" title="24">{
                builder.WriteString(e.Original.Error())
        }</span> else<span class="cov0" title="0"> {
                builder.WriteString("an error occurred")
        }</span>

        // Add source location if available
        <span class="cov9" title="24">if e.Context.Source != "" </span><span class="cov9" title="24">{
                builder.WriteString(fmt.Sprintf(" (source: %s", e.Context.Source))
                if e.Context.Line &gt; 0 </span><span class="cov9" title="24">{
                        builder.WriteString(fmt.Sprintf(":%d", e.Context.Line))
                }</span>
                <span class="cov9" title="24">builder.WriteString(")")</span>
        }

        <span class="cov9" title="24">return builder.String()</span>
}

// Unwrap returns the original error.
func (e *ContextualError) Unwrap() error <span class="cov1" title="1">{
        return e.Original
}</span>

// Code returns the error code.
func (e *ContextualError) Code() ErrorCode <span class="cov1" title="1">{
        return e.Context.Code
}</span>

// HTTPStatus returns the HTTP status code.
func (e *ContextualError) HTTPStatus() int <span class="cov1" title="1">{
        return e.Context.HTTPStatus
}</span>

// MarshalJSON implements the json.Marshaler interface.
func (e *ContextualError) MarshalJSON() ([]byte, error) <span class="cov4" title="3">{
        return json.Marshal(struct {
                Message string       `json:"message"`
                Context ErrorContext `json:"context,omitempty"`
        }{
                Message: e.Error(),
                Context: e.Context,
        })
}</span>

// getCallerInfo returns the file name and line number of the caller.
func getCallerInfo(skip int) (string, int) <span class="cov10" title="26">{
        _, file, line, ok := runtime.Caller(skip + 1)
        if !ok </span><span class="cov0" title="0">{
                return "", 0
        }</span>
        <span class="cov10" title="26">return filepath.Base(file), line</span>
}

// withContext wraps an error with contextual information.
// It adds operation name, error code, HTTP status, and source location to the error.
// If the error is already a ContextualError, it updates the context with the new information.
func withContext(err error, operation string, code ErrorCode, httpStatus int, details map[string]interface{}) error <span class="cov9" title="23">{
        // Get caller information
        source, line := getCallerInfo(2)

        // If the error is already a ContextualError, update its context
        var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov1" title="1">{
                // Only update operation if it's not already set
                if operation != "" &amp;&amp; contextualErr.Context.Operation == "" </span><span class="cov0" title="0">{
                        contextualErr.Context.Operation = operation
                }</span>

                // Only update code if it's not already set
                <span class="cov1" title="1">if code != "" &amp;&amp; contextualErr.Context.Code == "" </span><span class="cov0" title="0">{
                        contextualErr.Context.Code = code
                }</span>

                // Only update HTTP status if it's not already set
                <span class="cov1" title="1">if httpStatus != 0 &amp;&amp; contextualErr.Context.HTTPStatus == 0 </span><span class="cov0" title="0">{
                        contextualErr.Context.HTTPStatus = httpStatus
                }</span>

                // Merge details if provided
                <span class="cov1" title="1">if details != nil </span><span class="cov1" title="1">{
                        if contextualErr.Context.Details == nil </span><span class="cov0" title="0">{
                                contextualErr.Context.Details = make(map[string]interface{})
                        }</span>
                        <span class="cov1" title="1">for k, v := range details </span><span class="cov1" title="1">{
                                contextualErr.Context.Details[k] = v
                        }</span>
                }

                <span class="cov1" title="1">return contextualErr</span>
        }

        // Create a new ContextualError
        <span class="cov9" title="22">return &amp;ContextualError{
                Original: err,
                Context: ErrorContext{
                        Operation:  operation,
                        Source:     source,
                        Line:       line,
                        Code:       code,
                        HTTPStatus: httpStatus,
                        Details:    details,
                },
        }</span>
}

// AppError is a generic error type that can be used for different error categories
type AppError[T ~string] struct {
        Err     error
        Message string
        Code    string
        Type    T
}

func (e *AppError[T]) Error() string <span class="cov4" title="4">{
        if e.Message != "" </span><span class="cov4" title="3">{
                return e.Message
        }</span>
        <span class="cov1" title="1">return e.Err.Error()</span>
}

func (e *AppError[T]) Unwrap() error <span class="cov1" title="1">{
        return e.Err
}</span>

func (e *AppError[T]) ErrorType() T <span class="cov1" title="1">{
        return e.Type
}</span>

// NewAppError creates a new AppError
func NewAppError[T ~string](err error, message, code string, errorType T) *AppError[T] <span class="cov2" title="2">{
        return &amp;AppError[T]{
                Err:     err,
                Message: message,
                Code:    code,
                Type:    errorType,
        }
}</span>

// Map of error codes to HTTP status codes
var errorCodeToHTTPStatus = map[ErrorCode]int{
        NotFoundCode:              http.StatusNotFound,
        InvalidInputCode:          http.StatusBadRequest,
        DatabaseErrorCode:         http.StatusInternalServerError,
        InternalErrorCode:         http.StatusInternalServerError,
        TimeoutCode:               http.StatusGatewayTimeout,
        CanceledCode:              http.StatusRequestTimeout,
        AlreadyExistsCode:         http.StatusConflict,
        UnauthorizedCode:          http.StatusUnauthorized,
        ForbiddenCode:             http.StatusForbidden,
        ValidationErrorCode:       http.StatusBadRequest,
        BusinessRuleViolationCode: http.StatusUnprocessableEntity,
        ExternalServiceErrorCode:  http.StatusBadGateway,
        NetworkErrorCode:          http.StatusServiceUnavailable,
        ConfigurationErrorCode:    http.StatusInternalServerError,
        ResourceExhaustedCode:     http.StatusTooManyRequests,
        DataCorruptionCode:        http.StatusInternalServerError,
        ConcurrencyErrorCode:      http.StatusConflict,
}

// NotFound creates a new error for when a resource is not found.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with NotFoundCode and HTTP 404 status
func NotFound(format string, args ...interface{}) error <span class="cov4" title="4">{
        return withContext(fmt.Errorf(format, args...), "", NotFoundCode, http.StatusNotFound, nil)
}</span>

// InvalidInput creates a new error for when input validation fails.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with InvalidInputCode and HTTP 400 status
func InvalidInput(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", InvalidInputCode, http.StatusBadRequest, nil)
}</span>

// DatabaseOperation creates a new error for database operation failures.
// Parameters:
//   - err: The original error
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with DatabaseErrorCode and HTTP 500 status
func DatabaseOperation(err error, format string, args ...interface{}) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov1" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov1" title="1">return withContext(err, "database", DatabaseErrorCode, http.StatusInternalServerError, nil)</span>
}

// Internal creates a new error for internal server errors.
// Parameters:
//   - err: The original error
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with InternalErrorCode and HTTP 500 status
func Internal(err error, format string, args ...interface{}) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov1" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov1" title="1">return withContext(err, "", InternalErrorCode, http.StatusInternalServerError, nil)</span>
}

// Timeout creates a new error for when an operation times out.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with TimeoutCode and HTTP 504 status
func Timeout(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", TimeoutCode, http.StatusGatewayTimeout, nil)
}</span>

// Canceled creates a new error for when an operation is canceled.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with CanceledCode and HTTP 408 status
func Canceled(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", CanceledCode, http.StatusRequestTimeout, nil)
}</span>

// AlreadyExists creates a new error for when a resource already exists.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with AlreadyExistsCode and HTTP 409 status
func AlreadyExists(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", AlreadyExistsCode, http.StatusConflict, nil)
}</span>

// Unauthorized creates a new error for authentication failures.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with UnauthorizedCode and HTTP 401 status
func Unauthorized(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", UnauthorizedCode, http.StatusUnauthorized, nil)
}</span>

// Forbidden creates a new error for authorization failures.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ForbiddenCode and HTTP 403 status
func Forbidden(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ForbiddenCode, http.StatusForbidden, nil)
}</span>

// Validation creates a new error for domain validation errors.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ValidationErrorCode and HTTP 400 status
func Validation(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ValidationErrorCode, http.StatusBadRequest, nil)
}</span>

// BusinessRuleViolation creates a new error for when a business rule is violated.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with BusinessRuleViolationCode and HTTP 422 status
func BusinessRuleViolation(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", BusinessRuleViolationCode, http.StatusUnprocessableEntity, nil)
}</span>

// ExternalService creates a new error for external service call failures.
// Parameters:
//   - err: The original error
//   - service: The name of the external service
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ExternalServiceErrorCode and HTTP 502 status
func ExternalService(err error, service string, format string, args ...interface{}) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov1" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov1" title="1">return withContext(err, fmt.Sprintf("external_service_%s", service), ExternalServiceErrorCode, http.StatusBadGateway, nil)</span>
}

// Network creates a new error for network-related errors.
// Parameters:
//   - err: The original error
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with NetworkErrorCode and HTTP 503 status
func Network(err error, format string, args ...interface{}) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf(format, args...)
        }</span> else<span class="cov1" title="1"> {
                err = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
        }</span>
        <span class="cov1" title="1">return withContext(err, "network", NetworkErrorCode, http.StatusServiceUnavailable, nil)</span>
}

// Configuration creates a new error for configuration errors.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ConfigurationErrorCode and HTTP 500 status
func Configuration(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "configuration", ConfigurationErrorCode, http.StatusInternalServerError, nil)
}</span>

// ResourceExhausted creates a new error for when a resource limit is reached.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ResourceExhaustedCode and HTTP 429 status
func ResourceExhausted(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ResourceExhaustedCode, http.StatusTooManyRequests, nil)
}</span>

// DataCorruption creates a new error for when data is corrupted.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with DataCorruptionCode and HTTP 500 status
func DataCorruption(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", DataCorruptionCode, http.StatusInternalServerError, nil)
}</span>

// Concurrency creates a new error for concurrency-related errors.
// Parameters:
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error with ConcurrencyErrorCode and HTTP 409 status
func Concurrency(format string, args ...interface{}) error <span class="cov1" title="1">{
        return withContext(fmt.Errorf(format, args...), "", ConcurrencyErrorCode, http.StatusConflict, nil)
}</span>

// Is checks if an error matches a target error.
// This is a wrapper around errors.Is that adds support for ContextualError.
// Parameters:
//   - err: The error to check
//   - target: The target error to match against
//
// Returns:
//   - bool: True if the error matches the target
func Is(err error, target error) bool <span class="cov4" title="3">{
        return errors.Is(err, target)
}</span>

// As finds the first error in err's chain that matches target.
// This is a wrapper around errors.As that adds support for ContextualError.
// Parameters:
//   - err: The error to check
//   - target: A pointer to the error type to match against
//
// Returns:
//   - bool: True if a match was found
func As(err error, target interface{}) bool <span class="cov9" title="21">{
        return errors.As(err, target)
}</span>

// Unwrap returns the underlying error.
// This is a wrapper around errors.Unwrap that adds support for ContextualError.
// Parameters:
//   - err: The error to unwrap
//
// Returns:
//   - error: The underlying error, or nil if there is none
func Unwrap(err error) error <span class="cov4" title="3">{
        return errors.Unwrap(err)
}</span>

// WrapWithOperation wraps an error with an operation name and message.
// It preserves the error chain and adds source location information.
// Parameters:
//   - err: The error to wrap
//   - operation: The name of the operation that failed
//   - format: The error message format string
//   - args: Arguments for the format string
//
// Returns:
//   - error: A new error that wraps the original error
func WrapWithOperation(err error, operation string, format string, args ...interface{}) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get caller information
        <span class="cov1" title="1">source, line := getCallerInfo(1)

        // If the error is already a ContextualError, update its context
        var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov0" title="0">{
                // Create a new ContextualError with the updated message and operation
                return &amp;ContextualError{
                        Original: contextualErr.Original,
                        Context: ErrorContext{
                                Operation:  operation,
                                Source:     source,
                                Line:       line,
                                Code:       contextualErr.Context.Code,
                                HTTPStatus: contextualErr.Context.HTTPStatus,
                                Details:    contextualErr.Context.Details,
                        },
                }
        }</span>

        // Create a new ContextualError
        <span class="cov1" title="1">return &amp;ContextualError{
                Original: err,
                Context: ErrorContext{
                        Operation: operation,
                        Source:    source,
                        Line:      line,
                },
        }</span>
}

// WithDetails adds details to an error.
// It preserves the error chain and adds additional context information.
// Parameters:
//   - err: The error to enhance
//   - details: A map of additional details to add to the error
//
// Returns:
//   - error: A new error with the added details
func WithDetails(err error, details map[string]interface{}) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get caller information
        <span class="cov1" title="1">source, line := getCallerInfo(1)

        // If the error is already a ContextualError, update its context
        var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov0" title="0">{
                // Merge the details
                newDetails := make(map[string]interface{})
                if contextualErr.Context.Details != nil </span><span class="cov0" title="0">{
                        for k, v := range contextualErr.Context.Details </span><span class="cov0" title="0">{
                                newDetails[k] = v
                        }</span>
                }
                <span class="cov0" title="0">for k, v := range details </span><span class="cov0" title="0">{
                        newDetails[k] = v
                }</span>

                // Create a new ContextualError with the merged details
                <span class="cov0" title="0">return &amp;ContextualError{
                        Original: contextualErr.Original,
                        Context: ErrorContext{
                                Operation:  contextualErr.Context.Operation,
                                Source:     source,
                                Line:       line,
                                Code:       contextualErr.Context.Code,
                                HTTPStatus: contextualErr.Context.HTTPStatus,
                                Details:    newDetails,
                        },
                }</span>
        }

        // Create a new ContextualError
        <span class="cov1" title="1">return &amp;ContextualError{
                Original: err,
                Context: ErrorContext{
                        Source:  source,
                        Line:    line,
                        Details: details,
                },
        }</span>
}

// GetCode returns the error code from an error.
// If the error is a ContextualError, it returns the code from the context.
// Otherwise, it returns an empty string.
// Parameters:
//   - err: The error to get the code from
//
// Returns:
//   - ErrorCode: The error code, or an empty string if not available
func GetCode(err error) ErrorCode <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="1">var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov1" title="1">{
                return contextualErr.Context.Code
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// GetHTTPStatus returns the HTTP status code from an error.
// If the error is a ContextualError, it returns the HTTP status from the context.
// Otherwise, it returns 0.
// Parameters:
//   - err: The error to get the HTTP status from
//
// Returns:
//   - int: The HTTP status code, or 0 if not available
func GetHTTPStatus(err error) int <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov1" title="1">var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov1" title="1">{
                return contextualErr.Context.HTTPStatus
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// ToJSON converts an error to a JSON string.
// If the error is a ContextualError, it uses the MarshalJSON method.
// Otherwise, it creates a simple JSON object with the error message.
// Parameters:
//   - err: The error to convert to JSON
//
// Returns:
//   - string: The JSON representation of the error
func ToJSON(err error) string <span class="cov2" title="2">{
        if err == nil </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov2" title="2">var contextualErr *ContextualError
        if errors.As(err, &amp;contextualErr) </span><span class="cov2" title="2">{
                jsonBytes, jsonErr := json.Marshal(contextualErr)
                if jsonErr != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`{"message":"Error marshaling error to JSON: %s"}`, jsonErr.Error())
                }</span>
                <span class="cov2" title="2">return string(jsonBytes)</span>
        }

        // For non-ContextualError errors, create a simple JSON object
        <span class="cov0" title="0">jsonBytes, jsonErr := json.Marshal(struct {
                Message string `json:"message"`
        }{
                Message: err.Error(),
        })
        if jsonErr != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"message":"Error marshaling error to JSON: %s"}`, jsonErr.Error())
        }</span>
        <span class="cov0" title="0">return string(jsonBytes)</span>
}

// DomainErrorType represents the type of domain error
type DomainErrorType string

// Domain error type constants
const (
        DomainErrorGeneral DomainErrorType = "DOMAIN_ERROR"
)

// DomainError represents an error that occurred in the domain layer
type DomainError = AppError[DomainErrorType]

// NewDomainError creates a new DomainError
func NewDomainError(err error, message, code string) *DomainError <span class="cov1" title="1">{
        return NewAppError(err, message, code, DomainErrorGeneral)
}</span>

// ValidationError represents a validation error
type ValidationError struct {
        Msg   string
        Field string
}

func (e *ValidationError) Error() string <span class="cov7" title="12">{
        if e.Field != "" </span><span class="cov7" title="9">{
                return fmt.Sprintf("validation error: %s (field: %s)", e.Msg, e.Field)
        }</span>
        <span class="cov4" title="3">return fmt.Sprintf("validation error: %s", e.Msg)</span>
}

// NewValidationError creates a new ValidationError
func NewValidationError(msg string) *ValidationError <span class="cov4" title="3">{
        return &amp;ValidationError{Msg: msg}
}</span>

// NewFieldValidationError creates a new ValidationError with a field name
func NewFieldValidationError(msg, field string) *ValidationError <span class="cov4" title="4">{
        return &amp;ValidationError{Msg: msg, Field: field}
}</span>

// ValidationErrors represents multiple validation errors
type ValidationErrors struct {
        Errors []*ValidationError
}

func (e *ValidationErrors) Error() string <span class="cov5" title="5">{
        if len(e.Errors) == 1 </span><span class="cov2" title="2">{
                return e.Errors[0].Error()
        }</span>

        <span class="cov4" title="3">msg := fmt.Sprintf("%d validation errors:", len(e.Errors))
        for i, err := range e.Errors </span><span class="cov6" title="7">{
                msg += fmt.Sprintf("\n  %d. %s", i+1, err.Error())
        }</span>
        <span class="cov4" title="3">return msg</span>
}

// NewValidationErrors creates a new ValidationErrors
func NewValidationErrors(errors ...*ValidationError) *ValidationErrors <span class="cov4" title="3">{
        return &amp;ValidationErrors{Errors: errors}
}</span>

// AddError adds a validation error to the collection
func (e *ValidationErrors) AddError(err *ValidationError) <span class="cov1" title="1">{
        e.Errors = append(e.Errors, err)
}</span>

// HasErrors returns true if there are any validation errors
func (e *ValidationErrors) HasErrors() bool <span class="cov4" title="3">{
        return len(e.Errors) &gt; 0
}</span>

// RepositoryError represents an error that occurred in the repository layer
type RepositoryError struct {
        Err     error
        Message string
        Code    string
}

func (e *RepositoryError) Error() string <span class="cov1" title="1">{
        if e.Message != "" </span><span class="cov1" title="1">{
                return e.Message
        }</span>
        <span class="cov0" title="0">return e.Err.Error()</span>
}

func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewRepositoryError creates a new RepositoryError
func NewRepositoryError(err error, message, code string) *RepositoryError <span class="cov1" title="1">{
        return &amp;RepositoryError{
                Err:     err,
                Message: message,
                Code:    code,
        }
}</span>

// NotFoundError represents a resource not found error
type NotFoundError struct {
        ResourceType string
        ID           string
}

func (e *NotFoundError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("%s with ID %s not found", e.ResourceType, e.ID)
}</span>

// NewNotFoundError creates a new NotFoundError
func NewNotFoundError(resourceType, id string) *NotFoundError <span class="cov1" title="1">{
        return &amp;NotFoundError{
                ResourceType: resourceType,
                ID:           id,
        }
}</span>

// Is implements the errors.Is interface for NotFoundError
func (e *NotFoundError) Is(target error) bool <span class="cov1" title="1">{
        return target == ErrNotFound
}</span>

// ApplicationError represents an error that occurred in the application layer
type ApplicationError struct {
        Err     error
        Message string
        Code    string
}

func (e *ApplicationError) Error() string <span class="cov1" title="1">{
        if e.Message != "" </span><span class="cov1" title="1">{
                return e.Message
        }</span>
        <span class="cov0" title="0">return e.Err.Error()</span>
}

func (e *ApplicationError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewApplicationError creates a new ApplicationError
func NewApplicationError(err error, message, code string) *ApplicationError <span class="cov1" title="1">{
        return &amp;ApplicationError{
                Err:     err,
                Message: message,
                Code:    code,
        }
}</span>

// Error represents a domain error with operation context
type Error struct {
        // Original is the original error
        Original error

        // Code is a machine-readable error code
        Code string

        // Message is a human-readable error message
        Message string

        // Op is the operation that caused the error
        Op string

        // Param is the parameter that caused the error
        Param string
}

// Error returns a string representation of the error
func (e *Error) Error() string <span class="cov4" title="3">{
        if e.Original != nil </span><span class="cov2" title="2">{
                return fmt.Sprintf("%s: %s: %v", e.Op, e.Message, e.Original)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s: %s", e.Op, e.Message)</span>
}

// Unwrap returns the original error
func (e *Error) Unwrap() error <span class="cov2" title="2">{
        return e.Original
}</span>

// Is reports whether the error is of the given target type
func (e *Error) Is(target error) bool <span class="cov0" title="0">{
        if target == nil </span><span class="cov0" title="0">{
                return e == nil
        }</span>

        <span class="cov0" title="0">t, ok := target.(*Error)
        if !ok </span><span class="cov0" title="0">{
                return errors.Is(e.Original, target)
        }</span>

        <span class="cov0" title="0">return e.Code == t.Code</span>
}

// New creates a new Error
func New(op, code, message string, original error) error <span class="cov2" title="2">{
        return &amp;Error{
                Original: original,
                Code:     code,
                Message:  message,
                Op:       op,
        }
}</span>

// Wrap wraps an error with additional context
func Wrap(err error, op, message string) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If it's already a domain error, just update the op and message
        <span class="cov1" title="1">if e, ok := err.(*Error); ok </span><span class="cov0" title="0">{
                return &amp;Error{
                        Original: e.Original,
                        Code:     e.Code,
                        Message:  message,
                        Op:       op,
                }
        }</span>

        // Otherwise, create a new domain error
        <span class="cov1" title="1">return &amp;Error{
                Original: err,
                Message:  message,
                Op:       op,
        }</span>
}

// IsNotFound returns true if the error is a not found error
func IsNotFound(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrNotFound)
}</span>

// IsInvalidInput returns true if the error is an invalid input error
func IsInvalidInput(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrInvalidInput)
}</span>

// IsUnauthorized returns true if the error is an unauthorized error
func IsUnauthorized(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrUnauthorized)
}</span>

// IsForbidden returns true if the error is a forbidden error
func IsForbidden(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrForbidden)
}</span>

// IsInternal returns true if the error is an internal error
func IsInternal(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrInternal)
}</span>

// IsTimeout returns true if the error is a timeout error
func IsTimeout(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrTimeout)
}</span>

// IsCancelled returns true if the error is a cancelled error
func IsCancelled(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrCancelled)
}</span>

// IsConflict returns true if the error is a conflict error
func IsConflict(err error) bool <span class="cov4" title="3">{
        return errors.Is(err, ErrConflict)
}</span>

// GenericError is a generic error type that can be used for different error categories
type GenericError[T any] struct {
        Err      error
        Message  string
        Code     string
        Category T
}

func (e *GenericError[T]) Error() string <span class="cov4" title="3">{
        if e.Message != "" </span><span class="cov2" title="2">{
                return e.Message
        }</span>
        <span class="cov1" title="1">return e.Err.Error()</span>
}

func (e *GenericError[T]) Unwrap() error <span class="cov1" title="1">{
        return e.Err
}</span>

// NewGenericError creates a new GenericError
func NewGenericError[T any](err error, message, code string, category T) *GenericError[T] <span class="cov1" title="1">{
        return &amp;GenericError[T]{
                Err:      err,
                Message:  message,
                Code:     code,
                Category: category,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package errors provides generic error interfaces and implementations that can be used across different applications.
package errors

import (
        "net/http"
)

// ErrorWithCode is an interface for errors that have an error code
type ErrorWithCode interface {
        error
        // Code returns the error code
        Code() string
}

// ErrorWithHTTPStatus is an interface for errors that have an HTTP status code
type ErrorWithHTTPStatus interface {
        error
        // HTTPStatus returns the HTTP status code
        HTTPStatus() int
}

// ValidationErrorInterface is an interface for validation errors
type ValidationErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsValidationError identifies this as a validation error
        IsValidationError() bool
}

// NotFoundErrorInterface is an interface for not found errors
type NotFoundErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsNotFoundError identifies this as a not found error
        IsNotFoundError() bool
}

// ApplicationErrorInterface is an interface for application errors
type ApplicationErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsApplicationError identifies this as an application error
        IsApplicationError() bool
}

// RepositoryErrorInterface is an interface for repository errors
type RepositoryErrorInterface interface {
        ErrorWithCode
        ErrorWithHTTPStatus
        // IsRepositoryError identifies this as a repository error
        IsRepositoryError() bool
}

// IsValidationError checks if an error is a validation error
func IsValidationError(err error) bool <span class="cov8" title="5">{
        var validationErr ValidationErrorInterface
        return As(err, &amp;validationErr)
}</span>

// IsNotFoundError checks if an error is a not found error
func IsNotFoundError(err error) bool <span class="cov8" title="5">{
        var notFoundErr NotFoundErrorInterface
        return As(err, &amp;notFoundErr)
}</span>

// IsApplicationError checks if an error is an application error
func IsApplicationError(err error) bool <span class="cov8" title="5">{
        var appErr ApplicationErrorInterface
        return As(err, &amp;appErr)
}</span>

// IsRepositoryError checks if an error is a repository error
func IsRepositoryError(err error) bool <span class="cov8" title="5">{
        var repoErr RepositoryErrorInterface
        return As(err, &amp;repoErr)
}</span>

// GetHTTPStatusFromError returns the HTTP status code for an error
func GetHTTPStatusFromError(err error) int <span class="cov10" title="7">{
        // Check if the error implements ErrorWithHTTPStatus
        if httpErr, ok := err.(ErrorWithHTTPStatus); ok </span><span class="cov8" title="5">{
                return httpErr.HTTPStatus()
        }</span>
        
        // Check specific error types
        <span class="cov4" title="2">if IsValidationError(err) </span><span class="cov0" title="0">{
                return http.StatusBadRequest
        }</span>
        <span class="cov4" title="2">if IsNotFoundError(err) </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov4" title="2">if IsApplicationError(err) || IsRepositoryError(err) </span><span class="cov0" title="0">{
                return http.StatusInternalServerError
        }</span>
        
        // Default status code
        <span class="cov4" title="2">return http.StatusInternalServerError</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/abitofhelp/servicelib/errors (interfaces: ErrorWithCode,ErrorWithHTTPStatus,ValidationErrorInterface,NotFoundErrorInterface,ApplicationErrorInterface,RepositoryErrorInterface)

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockErrorWithCode is a mock of ErrorWithCode interface.
type MockErrorWithCode struct {
        ctrl     *gomock.Controller
        recorder *MockErrorWithCodeMockRecorder
}

// MockErrorWithCodeMockRecorder is the mock recorder for MockErrorWithCode.
type MockErrorWithCodeMockRecorder struct {
        mock *MockErrorWithCode
}

// NewMockErrorWithCode creates a new mock instance.
func NewMockErrorWithCode(ctrl *gomock.Controller) *MockErrorWithCode <span class="cov0" title="0">{
        mock := &amp;MockErrorWithCode{ctrl: ctrl}
        mock.recorder = &amp;MockErrorWithCodeMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorWithCode) EXPECT() *MockErrorWithCodeMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockErrorWithCode) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockErrorWithCodeMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockErrorWithCode)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockErrorWithCode) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockErrorWithCodeMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockErrorWithCode)(nil).Error))
}</span>

// MockErrorWithHTTPStatus is a mock of ErrorWithHTTPStatus interface.
type MockErrorWithHTTPStatus struct {
        ctrl     *gomock.Controller
        recorder *MockErrorWithHTTPStatusMockRecorder
}

// MockErrorWithHTTPStatusMockRecorder is the mock recorder for MockErrorWithHTTPStatus.
type MockErrorWithHTTPStatusMockRecorder struct {
        mock *MockErrorWithHTTPStatus
}

// NewMockErrorWithHTTPStatus creates a new mock instance.
func NewMockErrorWithHTTPStatus(ctrl *gomock.Controller) *MockErrorWithHTTPStatus <span class="cov0" title="0">{
        mock := &amp;MockErrorWithHTTPStatus{ctrl: ctrl}
        mock.recorder = &amp;MockErrorWithHTTPStatusMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorWithHTTPStatus) EXPECT() *MockErrorWithHTTPStatusMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Error mocks base method.
func (m *MockErrorWithHTTPStatus) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockErrorWithHTTPStatusMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockErrorWithHTTPStatus)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockErrorWithHTTPStatus) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockErrorWithHTTPStatusMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockErrorWithHTTPStatus)(nil).HTTPStatus))
}</span>

// MockValidationErrorInterface is a mock of ValidationErrorInterface interface.
type MockValidationErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockValidationErrorInterfaceMockRecorder
}

// MockValidationErrorInterfaceMockRecorder is the mock recorder for MockValidationErrorInterface.
type MockValidationErrorInterfaceMockRecorder struct {
        mock *MockValidationErrorInterface
}

// NewMockValidationErrorInterface creates a new mock instance.
func NewMockValidationErrorInterface(ctrl *gomock.Controller) *MockValidationErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockValidationErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockValidationErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockValidationErrorInterface) EXPECT() *MockValidationErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockValidationErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockValidationErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockValidationErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockValidationErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockValidationErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockValidationErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockValidationErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockValidationErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockValidationErrorInterface)(nil).HTTPStatus))
}</span>

// IsValidationError mocks base method.
func (m *MockValidationErrorInterface) IsValidationError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsValidationError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsValidationError indicates an expected call of IsValidationError.
func (mr *MockValidationErrorInterfaceMockRecorder) IsValidationError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsValidationError", reflect.TypeOf((*MockValidationErrorInterface)(nil).IsValidationError))
}</span>

// MockNotFoundErrorInterface is a mock of NotFoundErrorInterface interface.
type MockNotFoundErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockNotFoundErrorInterfaceMockRecorder
}

// MockNotFoundErrorInterfaceMockRecorder is the mock recorder for MockNotFoundErrorInterface.
type MockNotFoundErrorInterfaceMockRecorder struct {
        mock *MockNotFoundErrorInterface
}

// NewMockNotFoundErrorInterface creates a new mock instance.
func NewMockNotFoundErrorInterface(ctrl *gomock.Controller) *MockNotFoundErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockNotFoundErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockNotFoundErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotFoundErrorInterface) EXPECT() *MockNotFoundErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockNotFoundErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockNotFoundErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockNotFoundErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockNotFoundErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockNotFoundErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockNotFoundErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).HTTPStatus))
}</span>

// IsNotFoundError mocks base method.
func (m *MockNotFoundErrorInterface) IsNotFoundError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsNotFoundError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsNotFoundError indicates an expected call of IsNotFoundError.
func (mr *MockNotFoundErrorInterfaceMockRecorder) IsNotFoundError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNotFoundError", reflect.TypeOf((*MockNotFoundErrorInterface)(nil).IsNotFoundError))
}</span>

// MockApplicationErrorInterface is a mock of ApplicationErrorInterface interface.
type MockApplicationErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockApplicationErrorInterfaceMockRecorder
}

// MockApplicationErrorInterfaceMockRecorder is the mock recorder for MockApplicationErrorInterface.
type MockApplicationErrorInterfaceMockRecorder struct {
        mock *MockApplicationErrorInterface
}

// NewMockApplicationErrorInterface creates a new mock instance.
func NewMockApplicationErrorInterface(ctrl *gomock.Controller) *MockApplicationErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockApplicationErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockApplicationErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplicationErrorInterface) EXPECT() *MockApplicationErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockApplicationErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockApplicationErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockApplicationErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockApplicationErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockApplicationErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockApplicationErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockApplicationErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockApplicationErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockApplicationErrorInterface)(nil).HTTPStatus))
}</span>

// IsApplicationError mocks base method.
func (m *MockApplicationErrorInterface) IsApplicationError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsApplicationError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsApplicationError indicates an expected call of IsApplicationError.
func (mr *MockApplicationErrorInterfaceMockRecorder) IsApplicationError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsApplicationError", reflect.TypeOf((*MockApplicationErrorInterface)(nil).IsApplicationError))
}</span>

// MockRepositoryErrorInterface is a mock of RepositoryErrorInterface interface.
type MockRepositoryErrorInterface struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryErrorInterfaceMockRecorder
}

// MockRepositoryErrorInterfaceMockRecorder is the mock recorder for MockRepositoryErrorInterface.
type MockRepositoryErrorInterfaceMockRecorder struct {
        mock *MockRepositoryErrorInterface
}

// NewMockRepositoryErrorInterface creates a new mock instance.
func NewMockRepositoryErrorInterface(ctrl *gomock.Controller) *MockRepositoryErrorInterface <span class="cov0" title="0">{
        mock := &amp;MockRepositoryErrorInterface{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryErrorInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryErrorInterface) EXPECT() *MockRepositoryErrorInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Code mocks base method.
func (m *MockRepositoryErrorInterface) Code() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Code")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Code indicates an expected call of Code.
func (mr *MockRepositoryErrorInterfaceMockRecorder) Code() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).Code))
}</span>

// Error mocks base method.
func (m *MockRepositoryErrorInterface) Error() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockRepositoryErrorInterfaceMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).Error))
}</span>

// HTTPStatus mocks base method.
func (m *MockRepositoryErrorInterface) HTTPStatus() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HTTPStatus")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// HTTPStatus indicates an expected call of HTTPStatus.
func (mr *MockRepositoryErrorInterfaceMockRecorder) HTTPStatus() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTPStatus", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).HTTPStatus))
}</span>

// IsRepositoryError mocks base method.
func (m *MockRepositoryErrorInterface) IsRepositoryError() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsRepositoryError")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsRepositoryError indicates an expected call of IsRepositoryError.
func (mr *MockRepositoryErrorInterfaceMockRecorder) IsRepositoryError() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRepositoryError", reflect.TypeOf((*MockRepositoryErrorInterface)(nil).IsRepositoryError))
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package graphql provides utilities for working with GraphQL.
package graphql

import (
        "context"
        "errors"

        myerrors "github.com/abitofhelp/servicelib/errors"
        "github.com/abitofhelp/servicelib/logging"
        "github.com/vektah/gqlparser/v2/gqlerror"
        "go.uber.org/zap"
)

// HandleError processes an error and returns an appropriate GraphQL error.
// It logs the error and converts it to a GraphQL error with appropriate extensions.
// Parameters:
//   - ctx: The context containing trace information
//   - err: The error to handle
//   - operation: The name of the operation that caused the error
//   - logger: The logger to use for logging the error
//
// Returns:
//   - error: A GraphQL error with appropriate extensions
func HandleError(ctx context.Context, err error, operation string, logger *logging.ContextLogger) error <span class="cov0" title="0">{
        // Check for context cancellation
        // Client cancellations are normal behavior for GraphQL clients like Apollo Client,
        // which may cancel in-flight requests when new requests are made for the same operation.
        // We log these at DEBUG level since they're not actual errors.
        if errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                logger.Debug(ctx, "Operation canceled by client",
                        zap.String("operation", operation))
                return &amp;gqlerror.Error{
                        Message: "Operation canceled",
                        Extensions: map[string]interface{}{
                                "code": "CANCELED",
                        },
                }
        }</span>

        <span class="cov0" title="0">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                logger.Error(ctx, "Operation timed out",
                        zap.String("operation", operation),
                        zap.Error(err))
                return &amp;gqlerror.Error{
                        Message: "Operation timed out",
                        Extensions: map[string]interface{}{
                                "code": "TIMEOUT",
                        },
                }
        }</span>

        // Log the error with context
        <span class="cov0" title="0">logger.Error(ctx, "GraphQL error",
                zap.String("operation", operation),
                zap.Error(err))

        // Convert to appropriate GraphQL error based on type
        switch e := err.(type) </span>{
        case *myerrors.ValidationError, *myerrors.ValidationErrors:<span class="cov0" title="0">
                return &amp;gqlerror.Error{
                        Message: e.Error(),
                        Extensions: map[string]interface{}{
                                "code": "VALIDATION_ERROR",
                        },
                }</span>
        case *myerrors.NotFoundError:<span class="cov0" title="0">
                return &amp;gqlerror.Error{
                        Message: e.Error(),
                        Extensions: map[string]interface{}{
                                "code": "NOT_FOUND",
                        },
                }</span>
        case *myerrors.DomainError:<span class="cov0" title="0">
                return &amp;gqlerror.Error{
                        Message: e.Error(),
                        Extensions: map[string]interface{}{
                                "code": e.Code,
                        },
                }</span>
        case *myerrors.ApplicationError:<span class="cov0" title="0">
                return &amp;gqlerror.Error{
                        Message: e.Error(),
                        Extensions: map[string]interface{}{
                                "code": e.Code,
                        },
                }</span>
        case *myerrors.RepositoryError:<span class="cov0" title="0">
                // Don't expose internal database errors to clients
                return &amp;gqlerror.Error{
                        Message: "An internal error occurred",
                        Extensions: map[string]interface{}{
                                "code": "INTERNAL_ERROR",
                        },
                }</span>
        default:<span class="cov0" title="0">
                // Generic error handling
                return &amp;gqlerror.Error{
                        Message: "An unexpected error occurred",
                        Extensions: map[string]interface{}{
                                "code": "INTERNAL_ERROR",
                        },
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package graphql provides utilities for working with GraphQL.
package graphql

import (
        "context"
        "errors"
        "time"

        "github.com/99designs/gqlgen/graphql"
        "github.com/99designs/gqlgen/graphql/handler"
        "github.com/99designs/gqlgen/graphql/handler/extension"
        "github.com/abitofhelp/servicelib/logging"
        "github.com/abitofhelp/servicelib/middleware"
        "github.com/vektah/gqlparser/v2/gqlerror"
        "go.uber.org/zap"
)

// ServerConfig contains configuration for the GraphQL server
type ServerConfig struct {
        MaxQueryDepth      int
        MaxQueryComplexity int
        RequestTimeout     time.Duration
}

// NewDefaultServerConfig creates a new server configuration with default values
func NewDefaultServerConfig() ServerConfig <span class="cov0" title="0">{
        return ServerConfig{
                MaxQueryDepth:      25,
                MaxQueryComplexity: 100,
                RequestTimeout:     30 * time.Second,
        }
}</span>

// NewServer creates a new GraphQL server with the given schema and configuration
func NewServer(schema graphql.ExecutableSchema, logger *logging.ContextLogger, cfg ServerConfig) *handler.Server <span class="cov0" title="0">{
        // Create server with configurations
        server := handler.NewDefaultServer(schema)

        // 1. Request validation
        server.Use(extension.FixedComplexityLimit(cfg.MaxQueryComplexity))
        server.Use(&amp;extension.ComplexityLimit{
                Func: func(ctx context.Context, rc *graphql.OperationContext) int </span><span class="cov0" title="0">{
                        return cfg.MaxQueryDepth
                }</span>,
        })

        // 2. Error handling
        <span class="cov0" title="0">server.SetRecoverFunc(func(ctx context.Context, err interface{}) error </span><span class="cov0" title="0">{
                logger.Error(ctx, "GraphQL panic recovered",
                        zap.Any("error", err),
                        zap.String("request_id", middleware.RequestID(ctx)),
                )
                return &amp;gqlerror.Error{
                        Message: "Internal server error",
                        Extensions: map[string]interface{}{
                                "code": "INTERNAL_ERROR",
                                "time": time.Now().Format(time.RFC3339),
                        },
                }
        }</span>)

        // 3. Response formatting with improved context cancellation handling
        <span class="cov0" title="0">server.SetErrorPresenter(func(ctx context.Context, err error) *gqlerror.Error </span><span class="cov0" title="0">{
                // Get request ID for logging and error responses
                requestID := middleware.RequestID(ctx)
                timestamp := time.Now().UTC().Format(time.RFC3339)

                // Check if it's already a GraphQL error
                var gqlErr *gqlerror.Error
                if errors.As(err, &amp;gqlErr) </span><span class="cov0" title="0">{
                        return gqlErr
                }</span>

                // Handle context cancellation
                <span class="cov0" title="0">if errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                        // Log at debug level
                        logger.Debug(ctx, "Request context was canceled",
                                zap.String("request_id", requestID),
                                zap.Error(err),
                        )

                        // Return a more informative error message
                        return &amp;gqlerror.Error{
                                Message: "The request was interrupted. This could be due to a client disconnect.",
                                Extensions: map[string]interface{}{
                                        "code":       "CLIENT_DISCONNECTED",
                                        "timestamp":  timestamp,
                                        "request_id": requestID,
                                },
                        }
                }</span>

                // Handle timeout
                <span class="cov0" title="0">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        // Log at debug level
                        logger.Debug(ctx, "Request timed out",
                                zap.String("request_id", requestID),
                                zap.Error(err),
                        )

                        // Return a timeout-specific error message
                        return &amp;gqlerror.Error{
                                Message: "The request timed out. Please try again with a simpler query or contact support if the issue persists.",
                                Extensions: map[string]interface{}{
                                        "code":       "TIMEOUT",
                                        "timestamp":  timestamp,
                                        "request_id": requestID,
                                },
                        }
                }</span>

                // Log detailed error internally for other types of errors
                <span class="cov0" title="0">logger.Error(ctx, "GraphQL error",
                        zap.Error(err),
                        zap.String("request_id", requestID),
                )

                // Return formatted error to client
                return &amp;gqlerror.Error{
                        Message: "An error occurred while processing your request",
                        Extensions: map[string]interface{}{
                                "code":       "INTERNAL_ERROR",
                                "timestamp":  timestamp,
                                "request_id": requestID,
                        },
                }</span>
        })

        // 4. Query complexity limits
        <span class="cov0" title="0">server.Use(extension.FixedComplexityLimit(cfg.MaxQueryComplexity))

        // Add request validation middleware with proper context cancellation handling
        server.AroundOperations(createAroundOperationsFunc(logger, cfg.RequestTimeout))

        return server</span>
}

// createAroundOperationsFunc creates a function that wraps GraphQL operations with timeout and cancellation handling
func createAroundOperationsFunc(logger *logging.ContextLogger, requestTimeout time.Duration) graphql.OperationMiddleware <span class="cov0" title="0">{
        return func(ctx context.Context, next graphql.OperationHandler) graphql.ResponseHandler </span><span class="cov0" title="0">{
                op := graphql.GetOperationContext(ctx)

                // Validate operation name
                if op.Operation.Name == "" </span><span class="cov0" title="0">{
                        return func(ctx context.Context) *graphql.Response </span><span class="cov0" title="0">{
                                return &amp;graphql.Response{
                                        Errors: gqlerror.List{{
                                                Message: "Operation must have a name",
                                                Extensions: map[string]interface{}{
                                                        "code": "VALIDATION_ERROR",
                                                },
                                        }},
                                }
                        }</span>
                }

                // Create a new context with timeout
                <span class="cov0" title="0">timeoutCtx, timeoutCancel := context.WithTimeout(ctx, requestTimeout)

                // Create a done channel to signal when processing is complete
                done := make(chan struct{})

                // Get the response handler using the timeout context
                responseHandler := next(timeoutCtx)

                // Return a wrapped response handler that handles context cancellation
                return func(ctx context.Context) *graphql.Response </span><span class="cov0" title="0">{
                        // Check if the parent context was already cancelled
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                timeoutCancel() // Cancel our timeout context
                                logger.Debug(ctx, "Parent context was cancelled before processing",
                                        zap.String("request_id", middleware.RequestID(ctx)),
                                        zap.Error(ctx.Err()),
                                )
                                return &amp;graphql.Response{
                                        Errors: gqlerror.List{{
                                                Message: "The request was interrupted. This could be due to a client disconnect or a server-side timeout.",
                                                Extensions: map[string]interface{}{
                                                        "code":       "REQUEST_INTERRUPTED",
                                                        "timestamp":  time.Now().UTC().Format(time.RFC3339),
                                                        "request_id": middleware.RequestID(ctx),
                                                },
                                        }},
                                }
                        }</span>

                        // Process the response in a goroutine
                        <span class="cov0" title="0">var resp *graphql.Response
                        go func() </span><span class="cov0" title="0">{
                                resp = responseHandler(timeoutCtx)
                                close(done)
                        }</span>()

                        // Wait for either completion, parent context cancellation, or timeout
                        <span class="cov0" title="0">select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                // Request completed normally
                                timeoutCancel() // Clean up the timeout context
                                return resp</span>

                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Parent context was cancelled (client disconnected)
                                timeoutCancel() // Cancel our timeout context
                                logger.Debug(ctx, "Parent context was cancelled during processing",
                                        zap.String("request_id", middleware.RequestID(ctx)),
                                        zap.Error(ctx.Err()),
                                )
                                return &amp;graphql.Response{
                                        Errors: gqlerror.List{{
                                                Message: "The request was interrupted. This could be due to a client disconnect.",
                                                Extensions: map[string]interface{}{
                                                        "code":       "CLIENT_DISCONNECTED",
                                                        "timestamp":  time.Now().UTC().Format(time.RFC3339),
                                                        "request_id": middleware.RequestID(ctx),
                                                },
                                        }},
                                }</span>

                        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                                // Our timeout context expired
                                logger.Debug(ctx, "Request timed out",
                                        zap.String("request_id", middleware.RequestID(ctx)),
                                        zap.Duration("timeout", requestTimeout),
                                )
                                return &amp;graphql.Response{
                                        Errors: gqlerror.List{{
                                                Message: "The request timed out. Please try again with a simpler query or contact support if the issue persists.",
                                                Extensions: map[string]interface{}{
                                                        "code":       "TIMEOUT",
                                                        "timestamp":  time.Now().UTC().Format(time.RFC3339),
                                                        "request_id": middleware.RequestID(ctx),
                                                },
                                        }},
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package health provides functionality for health checking the application.
package health

// GenericContainerAdapter is a generic adapter for any container that implements RepositoryFactoryProvider
type GenericContainerAdapter[T RepositoryFactoryProvider] struct {
        Container T
}

// NewGenericContainerAdapter creates a new GenericContainerAdapter
func NewGenericContainerAdapter[T RepositoryFactoryProvider](container T) *GenericContainerAdapter[T] <span class="cov0" title="0">{
        return &amp;GenericContainerAdapter[T]{
                Container: container,
        }
}</span>

// GetRepositoryFactory returns the repository factory as an interface{}
func (a *GenericContainerAdapter[T]) GetRepositoryFactory() any <span class="cov0" title="0">{
        return a.Container.GetRepositoryFactory()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package health provides functionality for health checking applications.
package health

import (
        "github.com/abitofhelp/servicelib/config"
)

// ConfigAdapter adapts a config.Config to the HealthConfig interface
type ConfigAdapter struct {
        config config.Config
}

// NewConfigAdapter creates a new ConfigAdapter
func NewConfigAdapter(cfg config.Config) *ConfigAdapter <span class="cov0" title="0">{
        return &amp;ConfigAdapter{
                config: cfg,
        }
}</span>

// GetVersion returns the application version
func (a *ConfigAdapter) GetVersion() string <span class="cov0" title="0">{
        return a.config.GetApp().GetVersion()
}</span>

// GetTimeout returns the timeout for health checks
func (a *ConfigAdapter) GetTimeout() int <span class="cov0" title="0">{
        // Default to 5 seconds if not specified
        return 5
}</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package health provides functionality for health checking applications.
package health

import (
        "net/http"

        "github.com/abitofhelp/servicelib/config"
        "github.com/abitofhelp/servicelib/repository"
        "go.uber.org/zap"
)

// NewHealthHandler creates a new health check handler using the generic interfaces
func NewHealthHandler(
        repoFactory repository.RepositoryFactory,
        cfg config.Config,
        logger *zap.Logger,
) http.HandlerFunc <span class="cov0" title="0">{
        // Create adapters
        repoAdapter := NewRepositoryAdapter(repoFactory)
        configAdapter := NewConfigAdapter(cfg)

        // Create handler
        return NewGenericHandler(repoAdapter, configAdapter, logger, configAdapter.GetTimeout())
}</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package health provides functionality for health checking applications.
package health

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "go.uber.org/zap"
)

// GenericHealthStatus represents the health status response
type GenericHealthStatus struct {
        Status    string            `json:"status"`
        Timestamp string            `json:"timestamp"`
        Version   string            `json:"version"`
        Services  map[string]string `json:"services,omitempty"`
}

// NewGenericHandler creates a new health check HTTP handler that uses the generic interfaces
func NewGenericHandler(provider HealthCheckProvider, versionProvider VersionProvider, logger *zap.Logger, timeout int) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Create a context with timeout for the health check
                ctx, cancel := context.WithTimeout(r.Context(), time.Duration(timeout)*time.Second)
                defer cancel()

                // Use the context with timeout
                r = r.WithContext(ctx)

                // Check the health of dependencies
                services := make(map[string]string)

                // Check database connectivity through the repository factory
                repoFactory := provider.GetRepositoryFactory()
                if repoFactory != nil </span><span class="cov0" title="0">{
                        services["database"] = ServiceUp
                }</span> else<span class="cov0" title="0"> {
                        services["database"] = ServiceDown
                }</span>

                // Overall status is healthy if all dependencies are healthy
                <span class="cov0" title="0">status := StatusHealthy
                for _, s := range services </span><span class="cov0" title="0">{
                        if s != ServiceUp </span><span class="cov0" title="0">{
                                status = StatusDegraded
                                break</span>
                        }
                }

                // Create the health response
                <span class="cov0" title="0">healthResponse := GenericHealthStatus{
                        Status:    status,
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        Version:   versionProvider.GetVersion(),
                        Services:  services,
                }

                // Set content type
                w.Header().Set("Content-Type", "application/json")

                // Set appropriate status code based on health
                if status == StatusHealthy </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                }</span> else<span class="cov0" title="0"> {
                        w.WriteHeader(http.StatusServiceUnavailable)
                }</span>

                // Write the response
                <span class="cov0" title="0">if err := json.NewEncoder(w).Encode(healthResponse); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to encode health response", zap.Error(err))
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>

                // Log the health check
                <span class="cov0" title="0">logger.Info("Health check",
                        zap.String("status", status),
                        zap.Any("services", services),
                )</span>
        }
}</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package health provides functionality for health checking the application.
package health

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "github.com/abitofhelp/servicelib/config"
        "go.uber.org/zap"
)

// HealthStatus represents the health status response
type HealthStatus struct {
        Status    string            `json:"status"`
        Timestamp string            `json:"timestamp"`
        Version   string            `json:"version"`
        Services  map[string]string `json:"services,omitempty"`
}

// NewHandler creates a new health check HTTP handler
func NewHandler(provider HealthCheckProvider, logger *zap.Logger, cfg config.Config) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Create a context with timeout for the health check
                ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
                defer cancel()

                // Use the context with timeout
                r = r.WithContext(ctx)

                // Check the health of dependencies
                services := make(map[string]string)

                // Check database connectivity through the repository factory
                repoFactory := provider.GetRepositoryFactory()
                if repoFactory != nil </span><span class="cov0" title="0">{
                        services["database"] = ServiceUp
                }</span> else<span class="cov0" title="0"> {
                        services["database"] = ServiceDown
                }</span>

                // Overall status is healthy if all dependencies are healthy
                <span class="cov0" title="0">status := StatusHealthy
                for _, s := range services </span><span class="cov0" title="0">{
                        if s != ServiceUp </span><span class="cov0" title="0">{
                                status = StatusDegraded
                                break</span>
                        }
                }

                // Create the health response
                <span class="cov0" title="0">healthResponse := HealthStatus{
                        Status:    status, // Use the status constant directly
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        Version:   cfg.GetApp().GetVersion(),
                        Services:  services, // Use the services map directly
                }

                // Set content type
                w.Header().Set("Content-Type", "application/json")

                // Set appropriate status code based on health
                if status == StatusHealthy </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                }</span> else<span class="cov0" title="0"> {
                        w.WriteHeader(http.StatusServiceUnavailable)
                }</span>

                // Write the response
                <span class="cov0" title="0">if err := json.NewEncoder(w).Encode(healthResponse); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to encode health response", zap.Error(err))
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>

                // Log the health check
                <span class="cov0" title="0">logger.Info("Health check",
                        zap.String("status", status),
                        zap.Any("services", services),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package health provides functionality for health checking applications.
package health

import (
        "github.com/abitofhelp/servicelib/repository"
)

// RepositoryAdapter adapts a repository.RepositoryFactory to the RepositoryFactoryProvider interface
type RepositoryAdapter struct {
        factory repository.RepositoryFactory
}

// NewRepositoryAdapter creates a new RepositoryAdapter
func NewRepositoryAdapter(factory repository.RepositoryFactory) *RepositoryAdapter <span class="cov0" title="0">{
        return &amp;RepositoryAdapter{
                factory: factory,
        }
}</span>

// GetRepositoryFactory returns the repository factory
func (a *RepositoryAdapter) GetRepositoryFactory() any <span class="cov0" title="0">{
        return a.factory.GetRepository()
}</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package health provides functionality for health checking applications.
package health


// ConfigVersionAdapter adapts a config to the VersionProvider interface
type ConfigVersionAdapter struct {
        version string
}

// NewConfigVersionAdapter creates a new ConfigVersionAdapter
func NewConfigVersionAdapter(version string) *ConfigVersionAdapter <span class="cov0" title="0">{
        return &amp;ConfigVersionAdapter{
                version: version,
        }
}</span>

// GetVersion returns the application version
func (a *ConfigVersionAdapter) GetVersion() string <span class="cov0" title="0">{
        return a.version
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package logging provides centralized logging functionality for the family service.
// It wraps the zap logging library and adds features like trace ID extraction from context
// and context-aware logging methods. This package is part of the infrastructure layer
// and provides logging capabilities to all other layers of the application.
package logging

import (
        "context"
        "os"

        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewLogger creates a new zap logger configured based on the provided level and environment.
// It sets up appropriate encoders and log levels for either development or production use.
// Parameters:
//   - level: The minimum log level as a string (e.g., "debug", "info", "warn", "error")
//   - development: Whether to use development mode with console output (true) or production mode with JSON output (false)
//
// Returns:
//   - *zap.Logger: A configured zap logger instance
//   - error: An error if logger creation fails
func NewLogger(level string, development bool) (*zap.Logger, error) <span class="cov6" title="3">{
        // Parse log level
        var zapLevel zapcore.Level
        err := zapLevel.UnmarshalText([]byte(level))
        if err != nil </span><span class="cov1" title="1">{
                // Default to info level if parsing fails
                zapLevel = zapcore.InfoLevel
        }</span>

        // Create encoder config
        <span class="cov6" title="3">encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "time",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.LowercaseLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.StringDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        // Create core
        var core zapcore.Core
        if development </span><span class="cov1" title="1">{
                // In development mode, log to console with colored output
                consoleEncoder := zapcore.NewConsoleEncoder(encoderConfig)
                core = zapcore.NewCore(consoleEncoder, zapcore.AddSync(os.Stdout), zapLevel)
        }</span> else<span class="cov4" title="2"> {
                // In production mode, log as JSON
                jsonEncoder := zapcore.NewJSONEncoder(encoderConfig)
                core = zapcore.NewCore(jsonEncoder, zapcore.AddSync(os.Stdout), zapLevel)
        }</span>

        // Create logger
        <span class="cov6" title="3">logger := zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))

        return logger, nil</span>
}

// WithTraceID adds trace ID and span ID to the logger from the provided context.
// This enables correlation between logs and traces for distributed tracing.
// Parameters:
//   - ctx: The context containing trace information
//   - logger: The base logger to enhance with trace information
//
// Returns:
//   - *zap.Logger: A new logger with trace ID and span ID fields added if available
func WithTraceID(ctx context.Context, logger *zap.Logger) *zap.Logger <span class="cov10" title="7">{
        spanCtx := trace.SpanContextFromContext(ctx)
        if spanCtx.IsValid() </span><span class="cov9" title="6">{
                return logger.With(
                        zap.String("trace_id", spanCtx.TraceID().String()),
                        zap.String("span_id", spanCtx.SpanID().String()),
                )
        }</span>
        <span class="cov1" title="1">return logger</span>
}

// ContextLogger is a logger that includes context information in log entries.
// It wraps a zap.Logger and provides methods that accept a context parameter,
// automatically extracting and including trace information in log entries.
type ContextLogger struct {
        // base is the underlying zap logger instance
        base *zap.Logger
}

// NewContextLogger creates a new context-aware logger wrapping the provided base logger.
// Parameters:
//   - base: The base zap logger to wrap
//
// Returns:
//   - *ContextLogger: A new context logger instance
func NewContextLogger(base *zap.Logger) *ContextLogger <span class="cov7" title="4">{
        return &amp;ContextLogger{
                base: base,
        }
}</span>

// With returns a logger with trace information from the given context.
// Parameters:
//   - ctx: The context containing trace information
//
// Returns:
//   - *zap.Logger: A logger with trace ID and span ID fields added if available
func (l *ContextLogger) With(ctx context.Context) *zap.Logger <span class="cov8" title="5">{
        return WithTraceID(ctx, l.base)
}</span>

// Debug logs a debug-level message with context information.
// Parameters:
//   - ctx: The context containing trace information
//   - msg: The message to log
//   - fields: Additional fields to include in the log entry
func (l *ContextLogger) Debug(ctx context.Context, msg string, fields ...zap.Field) <span class="cov1" title="1">{
        l.With(ctx).Debug(msg, fields...)
}</span>

// Info logs an info-level message with context information.
// Parameters:
//   - ctx: The context containing trace information
//   - msg: The message to log
//   - fields: Additional fields to include in the log entry
func (l *ContextLogger) Info(ctx context.Context, msg string, fields ...zap.Field) <span class="cov1" title="1">{
        l.With(ctx).Info(msg, fields...)
}</span>

// Warn logs a warning-level message with context information.
// Parameters:
//   - ctx: The context containing trace information
//   - msg: The message to log
//   - fields: Additional fields to include in the log entry
func (l *ContextLogger) Warn(ctx context.Context, msg string, fields ...zap.Field) <span class="cov1" title="1">{
        l.With(ctx).Warn(msg, fields...)
}</span>

// Error logs an error-level message with context information.
// Parameters:
//   - ctx: The context containing trace information
//   - msg: The message to log
//   - fields: Additional fields to include in the log entry
func (l *ContextLogger) Error(ctx context.Context, msg string, fields ...zap.Field) <span class="cov1" title="1">{
        l.With(ctx).Error(msg, fields...)
}</span>

// Fatal logs a fatal-level message with context information.
// This will terminate the program after logging the message.
// Parameters:
//   - ctx: The context containing trace information
//   - msg: The message to log
//   - fields: Additional fields to include in the log entry
func (l *ContextLogger) Fatal(ctx context.Context, msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.With(ctx).Fatal(msg, fields...)
}</span>

// Sync flushes any buffered log entries to their destination.
// This should be called before program termination to ensure all logs are written.
// Returns:
//   - error: An error if flushing fails
func (l *ContextLogger) Sync() error <span class="cov1" title="1">{
        return l.base.Sync()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

package middleware

import (
        "context"
        "fmt"
        "math/rand"
        "net/http"
        "runtime/debug"
        "time"

        "github.com/abitofhelp/servicelib/errors"
        "github.com/abitofhelp/servicelib/logging"
        "go.uber.org/zap"
)

// ContextKey is a type for context keys to avoid collisions
type ContextKey string

const (
        // RequestIDKey is the key for the request ID in the context
        RequestIDKey ContextKey = "request_id"

        // StartTimeKey is the key for the request start time in the context
        StartTimeKey ContextKey = "start_time"

        // UserIDKey is the key for the user ID in the context (for future auth)
        UserIDKey ContextKey = "user_id"
)

// generateRequestID generates a simple unique ID for a request
func generateRequestID() string <span class="cov0" title="0">{
        // Initialize random number generator with current time
        rand.Seed(time.Now().UnixNano())

        // Generate a random number
        randomNum := rand.Intn(1000000)

        // Format the request ID using timestamp and random number
        return fmt.Sprintf("req-%d-%d", time.Now().UnixNano(), randomNum)
}</span>

// RequestID returns the request ID from the context
func RequestID(ctx context.Context) string <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if reqID, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov0" title="0">{
                return reqID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// StartTime returns the request start time from the context
func StartTime(ctx context.Context) time.Time <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">if startTime, ok := ctx.Value(StartTimeKey).(time.Time); ok </span><span class="cov0" title="0">{
                return startTime
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

// RequestDuration returns the duration since the request started
func RequestDuration(ctx context.Context) time.Duration <span class="cov0" title="0">{
        startTime := StartTime(ctx)
        if startTime.IsZero() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return time.Since(startTime)</span>
}

// WithRequestContext adds request context information to the request
func WithRequestContext(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Generate a request ID if not already present
                requestID := r.Header.Get("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = generateRequestID()
                }</span>

                // Add request ID to response headers
                <span class="cov0" title="0">w.Header().Set("X-Request-ID", requestID)

                // Create a new context with request information
                ctx := context.WithValue(r.Context(), RequestIDKey, requestID)
                ctx = context.WithValue(ctx, StartTimeKey, time.Now())

                // Call the next handler with the enhanced context
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// WithTimeout adds a timeout to the request context
func WithTimeout(timeout time.Duration) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Create a context with timeout
                        ctx, cancel := context.WithTimeout(r.Context(), timeout)
                        defer cancel()

                        // Create a channel to detect when the request is done
                        done := make(chan struct{})

                        // Process the request in a goroutine
                        go func() </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r.WithContext(ctx))
                                close(done)
                        }</span>()

                        // Wait for either the request to complete or the timeout to expire
                        <span class="cov0" title="0">select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                // Request completed normally
                                return</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Context timed out
                                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                        http.Error(w, "Request timeout", http.StatusGatewayTimeout)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                })
        }
}

// WithRecovery adds panic recovery to the request
func WithRecovery(logger *logging.ContextLogger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                // Log the panic
                                ctx := r.Context()
                                requestID := RequestID(ctx)

                                // Log the error with the request ID and stack trace
                                logger.Error(ctx, "Panic recovered",
                                        zap.String("request_id", requestID),
                                        zap.Any("error", err),
                                        zap.String("stack", string(debug.Stack())),
                                        zap.String("url", r.URL.String()),
                                        zap.String("method", r.Method),
                                )

                                // Return a 500 Internal Server Error response
                                w.Header().Set("Content-Type", "application/json")
                                w.WriteHeader(http.StatusInternalServerError)
                                _, writeErr := w.Write([]byte(`{"error":"Internal Server Error","request_id":"` + requestID + `"}`))
                                if writeErr != nil </span><span class="cov0" title="0">{
                                        logger.Error(ctx, "Failed to write error response", zap.Error(writeErr))
                                }</span>
                        }
                }()

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// WithLogging adds request logging
func WithLogging(logger *logging.ContextLogger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Record start time
                start := time.Now()

                // Create a response wrapper to capture the status code
                rw := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                // Process the request
                next.ServeHTTP(rw, r)

                // Calculate duration
                duration := time.Since(start)

                // Log the request
                ctx := r.Context()
                requestID := RequestID(ctx)

                // Use structured logger
                logger.Info(ctx, "Request completed",
                        zap.String("request_id", requestID),
                        zap.String("method", r.Method),
                        zap.String("path", r.URL.Path),
                        zap.Int("status", rw.statusCode),
                        zap.Duration("duration", duration))
        }</span>)
}

// responseWriter is a wrapper for http.ResponseWriter that captures the status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

// WriteHeader captures the status code
func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// Write captures the status code if not already set
func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if rw.statusCode == 0 </span><span class="cov0" title="0">{
                rw.statusCode = http.StatusOK
        }</span>
        <span class="cov0" title="0">return rw.ResponseWriter.Write(b)</span>
}

// WithErrorHandling adds centralized error handling
func WithErrorHandling(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Create a response wrapper to capture errors
                rw := &amp;errorResponseWriter{ResponseWriter: w}

                // Process the request
                next.ServeHTTP(rw, r)

                // Handle any captured error
                if rw.err != nil </span><span class="cov0" title="0">{
                        handleError(w, r, rw.err)
                }</span>
        })
}

// errorResponseWriter is a wrapper for http.ResponseWriter that captures errors
type errorResponseWriter struct {
        http.ResponseWriter
        err error
}

// SetError sets the error to be handled
func (rw *errorResponseWriter) SetError(err error) <span class="cov0" title="0">{
        rw.err = err
}</span>

// WithCORS adds CORS headers to allow cross-origin requests
func WithCORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Get the Origin header from the request
                origin := r.Header.Get("Origin")
                if origin == "" </span><span class="cov0" title="0">{
                        // If no Origin header is present, use a wildcard
                        w.Header().Set("Access-Control-Allow-Origin", "*")
                }</span> else<span class="cov0" title="0"> {
                        // If Origin header is present, echo it back
                        w.Header().Set("Access-Control-Allow-Origin", origin)
                        w.Header().Set("Access-Control-Allow-Credentials", "true")
                }</span>

                // Set other CORS headers
                <span class="cov0" title="0">w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
                w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Request-ID, X-Apollo-Operation-Name, Apollo-Require-Preflight, GraphQL-Query, GraphQL-Variables, GraphQL-Operation-Name, Origin, X-Requested-With")
                w.Header().Set("Access-Control-Expose-Headers", "X-Request-ID, Content-Length, Content-Type")
                w.Header().Set("Access-Control-Max-Age", "86400") // 24 hours

                // Handle preflight requests
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                // Call the next handler
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// WithContextCancellation is a middleware that checks for context cancellation
// It detects when a client disconnects and logs the event
func WithContextCancellation(logger *logging.ContextLogger) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Create a done channel to signal when the handler is complete
                        done := make(chan struct{})

                        // Create a copy of the request with a context that we can check
                        ctx, cancel := context.WithCancel(r.Context())
                        defer cancel()
                        r = r.WithContext(ctx)

                        // Create a timeout to prevent goroutine leaks
                        timeout := time.After(60 * time.Second)

                        go func() </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                close(done)
                        }</span>()

                        <span class="cov0" title="0">select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                // Request completed normally
                                return</span>
                        case &lt;-r.Context().Done():<span class="cov0" title="0">
                                // Client disconnected or request was cancelled
                                logger.Info(ctx, "Request cancelled by client",
                                        zap.String("url", r.URL.String()),
                                        zap.String("method", r.Method),
                                        zap.Error(r.Context().Err()),
                                )
                                // We don't need to send a response as the client has disconnected
                                cancel()
                                return</span>
                        case &lt;-timeout:<span class="cov0" title="0">
                                // Request took too long, log and cancel
                                logger.Warn(ctx, "Request timed out after 60 seconds",
                                        zap.String("url", r.URL.String()),
                                        zap.String("method", r.Method),
                                )
                                // Cancel the context to signal the handler to stop
                                cancel()
                                // Return a 504 Gateway Timeout response
                                w.WriteHeader(http.StatusGatewayTimeout)
                                _, writeErr := w.Write([]byte(`{"error":"Request timed out"}`))
                                if writeErr != nil </span><span class="cov0" title="0">{
                                        logger.Error(ctx, "Failed to write timeout response", zap.Error(writeErr))
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                })
        }
}

// ApplyMiddleware applies all middleware to a handler in the recommended order.
// This function provides a consistent way to apply middleware across different applications.
//
// Parameters:
//   - handler: The HTTP handler to wrap with middleware
//   - logger: Logger for recording middleware events
//
// Returns:
//   - A wrapped HTTP handler with all middleware applied
func ApplyMiddleware(handler http.Handler, logger *zap.Logger) http.Handler <span class="cov0" title="0">{
        // Create a context logger from the zap logger
        contextLogger := logging.NewContextLogger(logger)

        // Apply middleware in order (outermost first)
        // The order is important for proper middleware chaining

        // First add request context information
        wrappedHandler := WithRequestContext(handler)

        // Add CORS headers
        wrappedHandler = WithCORS(wrappedHandler)

        // Add recovery to catch panics
        wrappedHandler = WithRecovery(contextLogger, wrappedHandler)

        // Add context cancellation handling
        wrappedHandler = WithContextCancellation(contextLogger)(wrappedHandler)

        // Add request logging
        wrappedHandler = WithLogging(contextLogger, wrappedHandler)

        // Add error handling
        wrappedHandler = WithErrorHandling(wrappedHandler)

        return wrappedHandler
}</span>

// handleError maps errors to appropriate HTTP responses
func handleError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        // Set content type
        w.Header().Set("Content-Type", "application/json")

        // Map error types to status codes using the generic error interfaces
        statusCode := errors.GetHTTPStatusFromError(err)
        errorMessage := "Internal server error"

        // Get appropriate error message based on error type
        if errors.IsValidationError(err) || errors.IsNotFoundError(err) || errors.IsApplicationError(err) </span><span class="cov0" title="0">{
                errorMessage = err.Error()
        }</span> else<span class="cov0" title="0"> if errors.IsRepositoryError(err) </span><span class="cov0" title="0">{
                errorMessage = "Database error"
        }</span>

        // Set status code
        <span class="cov0" title="0">w.WriteHeader(statusCode)

        // Write error response
        w.Write([]byte(`{"error":"` + errorMessage + `","request_id":"` + RequestID(r.Context()) + `"}`))</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package model provides utilities for working with domain models and DTOs.
// It includes functions for copying fields between structs and creating deep copies of objects.
package model

import (
        "fmt"
        "reflect"
)

// CopyFields copies fields from source to destination based on field names.
// Both source and destination must be pointers to structs.
// Fields are copied only if they have the same name and compatible types.
//
// Parameters:
//   - dst: Pointer to the destination struct
//   - src: Pointer to the source struct
//
// Returns:
//   - error: An error if the operation fails
func CopyFields(dst, src interface{}) error <span class="cov4" title="4">{
        dstValue := reflect.ValueOf(dst)
        srcValue := reflect.ValueOf(src)

        // Check if both are pointers
        if dstValue.Kind() != reflect.Ptr || srcValue.Kind() != reflect.Ptr </span><span class="cov1" title="1">{
                return fmt.Errorf("both source and destination must be pointers")
        }</span>

        // Get the values that the pointers point to
        <span class="cov4" title="3">dstElem := dstValue.Elem()
        srcElem := srcValue.Elem()

        // Check if both are structs
        if dstElem.Kind() != reflect.Struct || srcElem.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return fmt.Errorf("both source and destination must be pointers to structs")
        }</span>

        // Get the type of the destination struct
        <span class="cov2" title="2">dstType := dstElem.Type()

        // Iterate through the fields of the destination struct
        for i := 0; i &lt; dstType.NumField(); i++ </span><span class="cov7" title="10">{
                dstField := dstType.Field(i)
                dstFieldValue := dstElem.Field(i)

                // Skip unexported fields
                if !dstFieldValue.CanSet() </span><span class="cov2" title="2">{
                        continue</span>
                }

                // Find the corresponding field in the source struct
                <span class="cov6" title="8">srcFieldValue := srcElem.FieldByName(dstField.Name)
                if !srcFieldValue.IsValid() </span><span class="cov4" title="3">{
                        continue</span>
                }

                // Check if the types are compatible
                <span class="cov5" title="5">if srcFieldValue.Type().AssignableTo(dstFieldValue.Type()) </span><span class="cov4" title="4">{
                        dstFieldValue.Set(srcFieldValue)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// DeepCopy creates a deep copy of the source object.
// Both source and destination must be pointers to structs of the same type.
//
// Parameters:
//   - dst: Pointer to the destination struct
//   - src: Pointer to the source struct
//
// Returns:
//   - error: An error if the operation fails
func DeepCopy(dst, src interface{}) error <span class="cov6" title="7">{
        dstValue := reflect.ValueOf(dst)
        srcValue := reflect.ValueOf(src)

        // Check if both are pointers
        if dstValue.Kind() != reflect.Ptr || srcValue.Kind() != reflect.Ptr </span><span class="cov1" title="1">{
                return fmt.Errorf("both source and destination must be pointers")
        }</span>

        // Get the values that the pointers point to
        <span class="cov6" title="6">dstElem := dstValue.Elem()
        srcElem := srcValue.Elem()

        // Check if both are structs
        if dstElem.Kind() != reflect.Struct || srcElem.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fmt.Errorf("both source and destination must be pointers to structs")
        }</span>

        // Check if they are of the same type
        <span class="cov6" title="6">if dstElem.Type() != srcElem.Type() </span><span class="cov1" title="1">{
                return fmt.Errorf("source and destination must be of the same type")
        }</span>

        // Perform the deep copy
        <span class="cov5" title="5">dstElem.Set(deepCopyValue(srcElem))

        return nil</span>
}

// deepCopyValue creates a deep copy of a reflect.Value.
// It handles various types including pointers, structs, slices, and maps.
//
// Parameters:
//   - src: The source value to copy
//
// Returns:
//   - reflect.Value: A deep copy of the source value
func deepCopyValue(src reflect.Value) reflect.Value <span class="cov10" title="25">{
        // Handle nil pointers
        if !src.IsValid() </span><span class="cov0" title="0">{
                return reflect.Value{}
        }</span>

        // Create a new value of the same type as src
        <span class="cov10" title="25">dst := reflect.New(src.Type()).Elem()

        switch src.Kind() </span>{
        case reflect.Ptr:<span class="cov2" title="2">
                // Handle nil pointers
                if src.IsNil() </span><span class="cov1" title="1">{
                        return dst
                }</span>
                // Create a new pointer
                <span class="cov1" title="1">v := deepCopyValue(src.Elem())
                dst.Set(reflect.New(v.Type()))
                dst.Elem().Set(v)</span>
        case reflect.Struct:<span class="cov6" title="6">
                // Copy each field
                for i := 0; i &lt; src.NumField(); i++ </span><span class="cov8" title="13">{
                        if dst.Field(i).CanSet() </span><span class="cov8" title="13">{
                                dst.Field(i).Set(deepCopyValue(src.Field(i)))
                        }</span>
                }
        case reflect.Slice:<span class="cov1" title="1">
                // Handle nil slices
                if src.IsNil() </span><span class="cov0" title="0">{
                        return dst
                }</span>
                // Create a new slice
                <span class="cov1" title="1">dst = reflect.MakeSlice(src.Type(), src.Len(), src.Cap())
                // Copy each element
                for i := 0; i &lt; src.Len(); i++ </span><span class="cov2" title="2">{
                        dst.Index(i).Set(deepCopyValue(src.Index(i)))
                }</span>
        case reflect.Map:<span class="cov1" title="1">
                // Handle nil maps
                if src.IsNil() </span><span class="cov0" title="0">{
                        return dst
                }</span>
                // Create a new map
                <span class="cov1" title="1">dst = reflect.MakeMap(src.Type())
                // Copy each key-value pair
                for _, key := range src.MapKeys() </span><span class="cov2" title="2">{
                        dst.SetMapIndex(deepCopyValue(key), deepCopyValue(src.MapIndex(key)))
                }</span>
        default:<span class="cov8" title="15">
                // For other types (int, string, etc.), just set the value
                dst.Set(src)</span>
        }

        <span class="cov9" title="24">return dst</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/abitofhelp/servicelib/repository (interfaces: Repository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockStringRepository is a mock of Repository interface for string entities.
type MockStringRepository struct {
        ctrl     *gomock.Controller
        recorder *MockStringRepositoryMockRecorder
}

// MockStringRepositoryMockRecorder is the mock recorder for MockStringRepository.
type MockStringRepositoryMockRecorder struct {
        mock *MockStringRepository
}

// NewMockStringRepository creates a new mock instance.
func NewMockStringRepository(ctrl *gomock.Controller) *MockStringRepository <span class="cov0" title="0">{
        mock := &amp;MockStringRepository{ctrl: ctrl}
        mock.recorder = &amp;MockStringRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStringRepository) EXPECT() *MockStringRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetByID mocks base method.
func (m *MockStringRepository) GetByID(ctx context.Context, id string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", ctx, id)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockStringRepositoryMockRecorder) GetByID(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockStringRepository)(nil).GetByID), ctx, id)
}</span>

// GetAll mocks base method.
func (m *MockStringRepository) GetAll(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", ctx)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockStringRepositoryMockRecorder) GetAll(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockStringRepository)(nil).GetAll), ctx)
}</span>

// Save mocks base method.
func (m *MockStringRepository) Save(ctx context.Context, entity string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockStringRepositoryMockRecorder) Save(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockStringRepository)(nil).Save), ctx, entity)
}</span>

// MockRepositoryFactory is a mock of RepositoryFactory interface.
type MockRepositoryFactory struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryFactoryMockRecorder
}

// MockRepositoryFactoryMockRecorder is the mock recorder for MockRepositoryFactory.
type MockRepositoryFactoryMockRecorder struct {
        mock *MockRepositoryFactory
}

// NewMockRepositoryFactory creates a new mock instance.
func NewMockRepositoryFactory(ctrl *gomock.Controller) *MockRepositoryFactory <span class="cov0" title="0">{
        mock := &amp;MockRepositoryFactory{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryFactoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryFactory) EXPECT() *MockRepositoryFactoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetRepository mocks base method.
func (m *MockRepositoryFactory) GetRepository() any <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRepository")
        ret0, _ := ret[0].(any)
        return ret0
}</span>

// GetRepository indicates an expected call of GetRepository.
func (mr *MockRepositoryFactoryMockRecorder) GetRepository() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepository", reflect.TypeOf((*MockRepositoryFactory)(nil).GetRepository))
}</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package shutdown provides functionality for graceful application shutdown.
package shutdown

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/abitofhelp/servicelib/logging"
        "go.uber.org/zap"
)

// GracefulShutdown waits for termination signals and calls the provided shutdown function.
// It handles OS signals (SIGINT, SIGTERM, SIGHUP) and context cancellation to trigger
// graceful shutdown. It also handles multiple signals, forcing exit if a second signal
// is received during shutdown. A default timeout of 30 seconds is applied to the shutdown
// function to prevent hanging.
//
// Parameters:
//   - ctx: Context that can be cancelled to trigger shutdown
//   - logger: Logger for recording shutdown events
//   - shutdownFunc: Function to execute during shutdown
//
// Returns:
//   - The error from the shutdown function, if any
func GracefulShutdown(ctx context.Context, logger *logging.ContextLogger, shutdownFunc func() error) error <span class="cov0" title="0">{
        // Create a channel to receive OS signals with buffer size 2 to avoid missing signals
        quit := make(chan os.Signal, 2)

        // Register for SIGINT, SIGTERM, and SIGHUP
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)

        // Make sure to stop signal handling when we're done
        defer signal.Stop(quit)

        // Create a channel to handle multiple signals
        done := make(chan struct{})
        var shutdownErr error

        // Start a goroutine to handle signals
        go func() </span><span class="cov0" title="0">{
                defer close(done)

                // Wait for either interrupt signal or context cancellation
                var shutdownReason string
                var shutdownDetails []zap.Field

                select </span>{
                case sig := &lt;-quit:<span class="cov0" title="0">
                        shutdownReason = "Received termination signal"
                        shutdownDetails = []zap.Field{
                                zap.String("signal", sig.String()),
                                zap.String("type", "first"),
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        shutdownReason = "Context cancelled, shutting down"
                        shutdownDetails = []zap.Field{
                                zap.Error(ctx.Err()),
                        }</span>
                }

                <span class="cov0" title="0">logger.Info(ctx, shutdownReason, shutdownDetails...)

                // Create a timeout context for the shutdown function
                shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer cancel()

                // Execute shutdown in a separate goroutine so we can monitor for timeout
                shutdownDone := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        defer close(shutdownDone)
                        // Call the shutdown function
                        logger.Info(ctx, "Executing shutdown function")
                        shutdownErr = shutdownFunc()
                }</span>()

                // Wait for shutdown to complete or timeout
                <span class="cov0" title="0">select </span>{
                case &lt;-shutdownDone:<span class="cov0" title="0">
                        // Shutdown completed within timeout
                        if shutdownErr != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Error during shutdown", zap.Error(shutdownErr))
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info(ctx, "Graceful shutdown completed successfully")
                        }</span>
                case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                        // Shutdown timed out
                        logger.Error(ctx, "Shutdown function timed out after 30 seconds")
                        shutdownErr = fmt.Errorf("shutdown function timed out after 30 seconds")</span>
                case sig := &lt;-quit:<span class="cov0" title="0">
                        // Received second signal during shutdown
                        logger.Warn(ctx, "Received second termination signal during shutdown, forcing exit",
                                zap.String("signal", sig.String()),
                                zap.String("type", "second"))
                        os.Exit(1)</span>
                }
        }()

        // Wait for shutdown to complete
        <span class="cov0" title="0">&lt;-done
        return shutdownErr</span>
}

// SetupGracefulShutdown sets up a goroutine that will handle graceful shutdown.
// It creates a new context with cancellation and starts a background goroutine
// that calls GracefulShutdown. This allows for both signal-based and programmatic
// shutdown initiation.
//
// Parameters:
//   - ctx: Parent context for the shutdown context
//   - logger: Logger for recording shutdown events
//   - shutdownFunc: Function to execute during shutdown
//
// Returns:
//   - A cancel function that can be called to trigger shutdown programmatically
//   - A channel that will receive any error that occurs during shutdown
func SetupGracefulShutdown(ctx context.Context, logger *logging.ContextLogger, shutdownFunc func() error) (context.CancelFunc, &lt;-chan error) <span class="cov0" title="0">{
        // Create a context with cancellation
        shutdownCtx, cancel := context.WithCancel(ctx)

        // Create a channel to receive shutdown errors
        // Buffer size 1 ensures we don't block if no one is listening
        errCh := make(chan error, 1)

        // Start a goroutine to handle shutdown
        go func() </span><span class="cov0" title="0">{
                // Execute the graceful shutdown
                err := GracefulShutdown(shutdownCtx, logger, shutdownFunc)

                // Send the error to the channel (nil if no error)
                select </span>{
                case errCh &lt;- err:<span class="cov0" title="0"></span>
                        // Error sent successfully
                default:<span class="cov0" title="0">
                        // No one is listening, just log the error
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Error during background graceful shutdown (no listener)", zap.Error(err))
                        }</span>
                }

                // Close the error channel to signal completion
                <span class="cov0" title="0">close(errCh)

                // Ensure context is cancelled when shutdown is complete
                cancel()</span>
        }()

        <span class="cov0" title="0">return cancel, errCh</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package signal provides utilities for handling OS signals and graceful shutdown.
package signal

import (
        "context"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/abitofhelp/servicelib/logging"
        "go.uber.org/zap"
)

// ShutdownCallback is a function that is called during shutdown
type ShutdownCallback func(ctx context.Context) error

// GracefulShutdown represents a graceful shutdown handler
type GracefulShutdown struct {
        timeout    time.Duration
        logger     *logging.ContextLogger
        callbacks  []ShutdownCallback
        callbackMu sync.Mutex
        signals    []os.Signal
}

// NewGracefulShutdown creates a new graceful shutdown handler
//
// Parameters:
//   - timeout: The maximum time to wait for shutdown callbacks to complete
//   - logger: The logger to use for logging shutdown events
//
// Returns:
//   - *GracefulShutdown: A new graceful shutdown handler
func NewGracefulShutdown(timeout time.Duration, logger *logging.ContextLogger) *GracefulShutdown <span class="cov0" title="0">{
        return &amp;GracefulShutdown{
                timeout:   timeout,
                logger:    logger,
                callbacks: make([]ShutdownCallback, 0),
                signals:   []os.Signal{syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP, syscall.SIGQUIT},
        }
}</span>

// RegisterCallback registers a callback to be called during shutdown
//
// Parameters:
//   - callback: The function to call during shutdown
func (gs *GracefulShutdown) RegisterCallback(callback ShutdownCallback) <span class="cov0" title="0">{
        gs.callbackMu.Lock()
        defer gs.callbackMu.Unlock()
        gs.callbacks = append(gs.callbacks, callback)
}</span>

// HandleShutdown handles graceful shutdown
// It returns a context that will be canceled when a shutdown signal is received
// and a cancel function that can be called to cancel the context manually
//
// Returns:
//   - context.Context: A context that will be canceled when a shutdown signal is received
//   - context.CancelFunc: A function that can be called to cancel the context manually
func (gs *GracefulShutdown) HandleShutdown() (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        go func() </span><span class="cov0" title="0">{
                // Create a channel to receive OS signals
                sigCh := make(chan os.Signal, 1)
                signal.Notify(sigCh, gs.signals...)

                // Wait for a signal
                sig := &lt;-sigCh
                gs.logger.Info(ctx, "Received shutdown signal", zap.String("signal", sig.String()))

                // Cancel the context to notify all services to shut down
                cancel()

                // Create a timeout context for shutdown
                timeoutCtx, timeoutCancel := context.WithTimeout(context.Background(), gs.timeout)
                defer timeoutCancel()

                // Execute registered callbacks
                gs.callbackMu.Lock()
                callbacks := make([]ShutdownCallback, len(gs.callbacks))
                copy(callbacks, gs.callbacks)
                gs.callbackMu.Unlock()

                var wg sync.WaitGroup
                for i, callback := range callbacks </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func(i int, cb ShutdownCallback) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                gs.logger.Info(ctx, "Executing shutdown callback", zap.Int("callback_index", i))
                                if err := cb(timeoutCtx); err != nil </span><span class="cov0" title="0">{
                                        gs.logger.Error(ctx, "Shutdown callback failed",
                                                zap.Int("callback_index", i),
                                                zap.Error(err))
                                }</span> else<span class="cov0" title="0"> {
                                        gs.logger.Info(ctx, "Shutdown callback completed successfully",
                                                zap.Int("callback_index", i))
                                }</span>
                        }(i, callback)
                }

                // Wait for callbacks to complete or timeout
                <span class="cov0" title="0">done := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        wg.Wait()
                        close(done)
                }</span>()

                // Wait for callbacks to complete, timeout, or second signal
                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        gs.logger.Info(ctx, "All shutdown callbacks completed successfully")</span>
                case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                        gs.logger.Warn(ctx, "Graceful shutdown timed out, forcing exit")</span>
                case sig := &lt;-sigCh:<span class="cov0" title="0">
                        gs.logger.Warn(ctx, "Received second signal, forcing exit",
                                zap.String("signal", sig.String()))</span>
                }

                // Force exit
                <span class="cov0" title="0">os.Exit(0)</span>
        }()

        <span class="cov0" title="0">return ctx, cancel</span>
}

// WaitForShutdown blocks until a shutdown signal is received
// It returns a context that will be canceled when a shutdown signal is received
//
// Parameters:
//   - timeout: The maximum time to wait for shutdown callbacks to complete
//   - logger: The logger to use for logging shutdown events
//
// Returns:
//   - context.Context: A context that will be canceled when a shutdown signal is received
func WaitForShutdown(timeout time.Duration, logger *logging.ContextLogger) context.Context <span class="cov0" title="0">{
        gs := NewGracefulShutdown(timeout, logger)
        ctx, _ := gs.HandleShutdown()
        return ctx
}</span>

// SetupSignalHandler sets up a signal handler for graceful shutdown
// It returns a context that will be canceled when a shutdown signal is received
// and the GracefulShutdown instance for registering callbacks
//
// Parameters:
//   - timeout: The maximum time to wait for shutdown callbacks to complete
//   - logger: The logger to use for logging shutdown events
//
// Returns:
//   - context.Context: A context that will be canceled when a shutdown signal is received
//   - *GracefulShutdown: The graceful shutdown handler for registering callbacks
func SetupSignalHandler(timeout time.Duration, logger *logging.ContextLogger) (context.Context, *GracefulShutdown) <span class="cov0" title="0">{
        gs := NewGracefulShutdown(timeout, logger)
        ctx, _ := gs.HandleShutdown()
        return ctx, gs
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package stringutil provides additional string manipulation utilities
// beyond what's available in the standard library.
package stringutil

import (
        "regexp"
        "strings"
)

// HasPrefixIgnoreCase checks if the string s begins with the specified prefix, ignoring case.
// It is safe for UTF-8 encoded strings and performs a case-insensitive comparison.
// Parameters:
//   - s: The string to check
//   - prefix: The prefix to look for at the beginning of s
//
// Returns:
//   - bool: true if s starts with prefix (ignoring case), false otherwise
func HasPrefixIgnoreCase(s, prefix string) bool <span class="cov8" title="7">{
        r := len(s) &gt;= len(prefix) &amp;&amp; strings.EqualFold(s[:len(prefix)], prefix)
        return r
}</span>

// ContainsIgnoreCase checks if substr is within s, ignoring case.
// Both s and substr are converted to lowercase before comparison.
// Parameters:
//   - s: The string to search in
//   - substr: The substring to search for
//
// Returns:
//   - bool: true if substr is found in s (ignoring case), false otherwise
func ContainsIgnoreCase(s, substr string) bool <span class="cov8" title="7">{
        return strings.Contains(strings.ToLower(s), strings.ToLower(substr))
}</span>

// HasAnyPrefix checks if the string s begins with any of the specified prefixes.
// It iterates through the provided prefixes and returns as soon as a match is found.
// Parameters:
//   - s: The string to check
//   - prefixes: One or more prefixes to look for at the beginning of s
//
// Returns:
//   - bool: true if s starts with any of the prefixes, false otherwise
func HasAnyPrefix(s string, prefixes ...string) bool <span class="cov8" title="6">{
        for _, prefix := range prefixes </span><span class="cov9" title="8">{
                if strings.HasPrefix(s, prefix) </span><span class="cov5" title="3">{
                        return true
                }</span>
        }
        <span class="cov5" title="3">return false</span>
}

// ToLowerCase converts a string to lowercase.
// It's a simple wrapper around strings.ToLower for consistency within the package.
// Parameters:
//   - s: The string to convert to lowercase
//
// Returns:
//   - string: The lowercase version of the input string
func ToLowerCase(s string) string <span class="cov7" title="5">{
        return strings.ToLower(s)
}</span>

// JoinWithAnd joins a slice of strings with commas and "and".
// It handles different list lengths appropriately and supports Oxford comma usage.
// Parameters:
//   - items: The slice of strings to join
//   - useOxfordComma: Whether to include a comma before "and" for lists of 3 or more items
//
// Returns:
//   - string: The joined string, or an empty string if items is empty
func JoinWithAnd(items []string, useOxfordComma bool) string <span class="cov9" title="8">{
        length := len(items)

        if length == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov8" title="7">if length == 1 </span><span class="cov1" title="1">{
                return items[0]
        }</span>

        <span class="cov8" title="6">if length == 2 </span><span class="cov3" title="2">{
                return items[0] + " and " + items[1]
        }</span>

        // For 3 or more items
        <span class="cov6" title="4">var result string
        for i := 0; i &lt; length-1; i++ </span><span class="cov10" title="10">{
                result += items[i] + ", "
        }</span>

        // Remove the trailing comma and space
        <span class="cov6" title="4">result = result[:len(result)-2]

        // Add the final part with or without Oxford comma
        if useOxfordComma </span><span class="cov3" title="2">{
                result += ", and " + items[length-1]
        }</span> else<span class="cov3" title="2"> {
                result += " and " + items[length-1]
        }</span>

        <span class="cov6" title="4">return result</span>
}

// IsEmpty checks if a string is empty or contains only whitespace.
// It uses strings.TrimSpace to remove all leading and trailing whitespace.
// Parameters:
//   - s: The string to check
//
// Returns:
//   - bool: true if the string is empty or contains only whitespace, false otherwise
func IsEmpty(s string) bool <span class="cov9" title="8">{
        return strings.TrimSpace(s) == ""
}</span>

// IsNotEmpty checks if a string is not empty and contains non-whitespace characters.
// It's the logical opposite of IsEmpty.
// Parameters:
//   - s: The string to check
//
// Returns:
//   - bool: true if the string contains non-whitespace characters, false otherwise
func IsNotEmpty(s string) bool <span class="cov6" title="4">{
        return !IsEmpty(s)
}</span>

// Truncate truncates a string to a specified maximum length.
// If the string is longer than maxLength, it adds "..." to the end.
// If maxLength is negative, it's treated as 0.
// Parameters:
//   - s: The string to truncate
//   - maxLength: The maximum length of the returned string before adding "..."
//
// Returns:
//   - string: The truncated string, or the original string if it's not longer than maxLength
func Truncate(s string, maxLength int) string <span class="cov8" title="6">{
        // Handle negative maxLength
        if maxLength &lt; 0 </span><span class="cov1" title="1">{
                maxLength = 0
        }</span>

        <span class="cov8" title="6">if len(s) &lt;= maxLength </span><span class="cov5" title="3">{
                return s
        }</span>
        <span class="cov5" title="3">return s[:maxLength] + "..."</span>
}

// RemoveWhitespace removes all whitespace characters from a string.
// It uses a regular expression to match and remove spaces, tabs, newlines, and other whitespace.
// Parameters:
//   - s: The string to process
//
// Returns:
//   - string: The string with all whitespace characters removed
func RemoveWhitespace(s string) string <span class="cov8" title="6">{
        re := regexp.MustCompile(`\s+`)
        return re.ReplaceAllString(s, "")
}</span>

// ForwardSlashPath converts backslashes in a path to forward slashes.
// This is useful for normalizing file paths across different operating systems.
// Parameters:
//   - path: The file path to normalize
//
// Returns:
//   - string: The path with all backslashes replaced by forward slashes
func ForwardSlashPath(path string) string <span class="cov6" title="4">{
        return strings.ReplaceAll(path, "\\", "/")
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package telemetry provides functionality for monitoring and tracing application behavior.
package telemetry

import (
        "github.com/knadh/koanf/v2"
)

// Config holds all telemetry configuration
type Config struct {
        // Enabled indicates whether telemetry is enabled
        Enabled bool `mapstructure:"enabled"`

        // ServiceName is the name of the service
        ServiceName string `mapstructure:"service_name"`

        // Environment is the environment the service is running in
        Environment string `mapstructure:"environment"`

        // Version is the version of the service
        Version string `mapstructure:"version"`

        // ShutdownTimeout is the timeout for shutting down telemetry in seconds
        ShutdownTimeout int `mapstructure:"shutdown_timeout"`

        // OTLP is the configuration for the OTLP exporter
        OTLP OTLPConfig `mapstructure:"otlp"`

        // Tracing is the configuration for tracing
        Tracing TracingConfig `mapstructure:"tracing"`

        // Metrics is the configuration for metrics
        Metrics MetricsConfig `mapstructure:"metrics"`

        // HTTP is the configuration for HTTP telemetry
        HTTP HTTPConfig `mapstructure:"http"`
}

// OTLPConfig holds configuration for OTLP exporter
type OTLPConfig struct {
        // Endpoint is the OTLP endpoint
        Endpoint string `mapstructure:"endpoint"`

        // Insecure indicates whether to use insecure connections
        Insecure bool `mapstructure:"insecure"`

        // Timeout is the timeout for OTLP operations in seconds
        Timeout int `mapstructure:"timeout_seconds"`
}

// TracingConfig holds configuration for tracing
type TracingConfig struct {
        // Enabled indicates whether tracing is enabled
        Enabled bool `mapstructure:"enabled"`

        // SamplingRatio is the ratio of traces to sample
        SamplingRatio float64 `mapstructure:"sampling_ratio"`

        // PropagationKeys are the keys to propagate in trace context
        PropagationKeys []string `mapstructure:"propagation_keys"`
}

// MetricsConfig holds configuration for metrics
type MetricsConfig struct {
        // Enabled indicates whether metrics are enabled
        Enabled bool `mapstructure:"enabled"`

        // ReportingFreq is the frequency of metrics reporting in seconds
        ReportingFreq int `mapstructure:"reporting_frequency_seconds"`

        // Prometheus is the configuration for Prometheus metrics
        Prometheus PrometheusConfig `mapstructure:"prometheus"`
}

// PrometheusConfig holds configuration for Prometheus metrics
type PrometheusConfig struct {
        // Enabled indicates whether Prometheus metrics are enabled
        Enabled bool `mapstructure:"enabled"`

        // Listen is the address to listen on for Prometheus metrics
        Listen string `mapstructure:"listen"`

        // Path is the path to expose Prometheus metrics on
        Path string `mapstructure:"path"`
}

// HTTPConfig holds configuration for HTTP telemetry
type HTTPConfig struct {
        // TracingEnabled indicates whether HTTP tracing is enabled
        TracingEnabled bool `mapstructure:"tracing_enabled"`
}

// LoadConfig loads telemetry configuration from koanf
//
// Parameters:
//   - k: The koanf instance to load configuration from
//
// Returns:
//   - Config: The loaded telemetry configuration
func LoadConfig(k *koanf.Koanf) Config <span class="cov0" title="0">{
        return Config{
                Enabled:         k.Bool("telemetry.enabled"),
                ServiceName:     k.String("telemetry.service_name"),
                Environment:     k.String("telemetry.environment"),
                Version:         k.String("telemetry.version"),
                ShutdownTimeout: k.Int("telemetry.shutdown_timeout"),
                OTLP: OTLPConfig{
                        Endpoint: k.String("telemetry.otlp.endpoint"),
                        Insecure: k.Bool("telemetry.otlp.insecure"),
                        Timeout:  k.Int("telemetry.otlp.timeout_seconds"),
                },
                Tracing: TracingConfig{
                        Enabled:         k.Bool("telemetry.tracing.enabled"),
                        SamplingRatio:   k.Float64("telemetry.tracing.sampling_ratio"),
                        PropagationKeys: k.Strings("telemetry.tracing.propagation_keys"),
                },
                Metrics: MetricsConfig{
                        Enabled:       k.Bool("telemetry.metrics.enabled"),
                        ReportingFreq: k.Int("telemetry.metrics.reporting_frequency_seconds"),
                        Prometheus: PrometheusConfig{
                                Enabled: k.Bool("telemetry.exporters.metrics.prometheus.enabled"),
                                Listen:  k.String("telemetry.exporters.metrics.prometheus.listen"),
                                Path:    k.String("telemetry.exporters.metrics.prometheus.path"),
                        },
                },
                HTTP: HTTPConfig{
                        TracingEnabled: k.Bool("telemetry.http.tracing_enabled"),
                },
        }
}</span>

// GetTelemetryDefaults returns default values for telemetry configuration
//
// Parameters:
//   - serviceName: The name of the service (optional, defaults to "service")
//
// Returns:
//   - map[string]interface{}: Default values for telemetry configuration
func GetTelemetryDefaults(serviceName ...string) map[string]interface{} <span class="cov0" title="0">{
        // Use the provided service name or default to "service"
        name := "service"
        if len(serviceName) &gt; 0 &amp;&amp; serviceName[0] != "" </span><span class="cov0" title="0">{
                name = serviceName[0]
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "telemetry.enabled":          true,
                "telemetry.service_name":     name,
                "telemetry.environment":      "development",
                "telemetry.version":          "1.0.0",
                "telemetry.shutdown_timeout": 5,

                // OTLP defaults
                "telemetry.otlp.endpoint":        "localhost:4317",
                "telemetry.otlp.insecure":        true,
                "telemetry.otlp.timeout_seconds": 5,

                // Tracing defaults
                "telemetry.tracing.enabled":          true,
                "telemetry.tracing.sampling_ratio":   1.0, // Sample everything by default
                "telemetry.tracing.propagation_keys": []string{"traceparent", "tracestate", "baggage"},

                // Metrics defaults
                "telemetry.metrics.enabled":                      true,
                "telemetry.metrics.reporting_frequency_seconds":  15,
                "telemetry.exporters.metrics.prometheus.enabled": true,
                "telemetry.exporters.metrics.prometheus.listen":  "0.0.0.0:8089",
                "telemetry.exporters.metrics.prometheus.path":    "/metrics",

                // HTTP defaults
                "telemetry.http.tracing_enabled": true,
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package telemetry provides functionality for monitoring and tracing application behavior.
package telemetry

import (
        "context"
        "net/http"

        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"

        "github.com/abitofhelp/servicelib/logging"
)

// InstrumentHandler wraps an http.Handler with OpenTelemetry instrumentation.
// This adds tracing to all HTTP requests handled by the provided handler.
//
// Parameters:
//   - handler: The HTTP handler to instrument
//   - operation: The name of the operation for tracing
//   - opts: Additional options for the instrumentation
//
// Returns:
//   - http.Handler: The instrumented HTTP handler
func InstrumentHandler(handler http.Handler, operation string, opts ...otelhttp.Option) http.Handler <span class="cov0" title="0">{
        return otelhttp.NewHandler(handler, operation, opts...)
}</span>

// InstrumentClient wraps an http.Client with OpenTelemetry instrumentation.
// This adds tracing to all HTTP requests made by the provided client.
//
// Parameters:
//   - client: The HTTP client to instrument
//   - opts: Additional options for the instrumentation
//
// Returns:
//   - *http.Client: The instrumented HTTP client
func InstrumentClient(client *http.Client, opts ...otelhttp.Option) *http.Client <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                client = http.DefaultClient
        }</span>

        <span class="cov0" title="0">client.Transport = otelhttp.NewTransport(
                client.Transport,
                opts...,
        )

        return client</span>
}

// NewHTTPMiddleware creates a new middleware for HTTP request tracing.
// This middleware adds tracing to all HTTP requests and logs request information.
//
// Parameters:
//   - logger: The logger to use for logging request information
//
// Returns:
//   - func(http.Handler) http.Handler: The middleware function
func NewHTTPMiddleware(logger *logging.ContextLogger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        tracer := otel.Tracer("infrastructure.telemetry.http")

        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx, span := tracer.Start(r.Context(), r.Method+" "+r.URL.Path)
                        defer span.End()

                        // Add common attributes to the span
                        span.SetAttributes(
                                attribute.String("http.method", r.Method),
                                attribute.String("http.url", r.URL.String()),
                                attribute.String("http.host", r.Host),
                                attribute.String("http.user_agent", r.UserAgent()),
                        )

                        // Add trace ID to response headers for debugging
                        traceID := span.SpanContext().TraceID().String()
                        w.Header().Set("X-Trace-ID", traceID)

                        // Log request with trace ID
                        logger.Info(ctx, "HTTP request",
                                zap.String("method", r.Method),
                                zap.String("path", r.URL.Path),
                                zap.String("trace_id", traceID),
                        )

                        // Call the next handler with the updated context
                        next.ServeHTTP(w, r.WithContext(ctx))
                }</span>)
        }
}

// StartSpan is a helper function to start a new span from a context.
// This is useful for tracing operations within a request.
//
// Parameters:
//   - ctx: The context to start the span from
//   - name: The name of the span
//
// Returns:
//   - context.Context: The context with the span
//   - trace.Span: The span
func StartSpan(ctx context.Context, name string) (context.Context, trace.Span) <span class="cov0" title="0">{
        tracer := otel.Tracer("infrastructure.telemetry")
        return tracer.Start(ctx, name)
}</span>

// AddSpanAttributes adds attributes to the current span in context.
// This is useful for adding additional information to a span.
//
// Parameters:
//   - ctx: The context containing the span
//   - attrs: The attributes to add to the span
func AddSpanAttributes(ctx context.Context, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        span.SetAttributes(attrs...)
}</span>

// RecordErrorSpan records an error on the current span in context.
// This is useful for recording errors that occur during a traced operation.
//
// Parameters:
//   - ctx: The context containing the span
//   - err: The error to record
//   - opts: Additional options for the error event
func RecordErrorSpan(ctx context.Context, err error, opts ...trace.EventOption) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                span := trace.SpanFromContext(ctx)
                span.RecordError(err, opts...)
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package telemetry provides functionality for monitoring and tracing application behavior.
package telemetry

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/knadh/koanf/v2"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
        "go.opentelemetry.io/otel/metric"
        sdkmetric "go.opentelemetry.io/otel/sdk/metric"
        "go.opentelemetry.io/otel/sdk/resource"
        semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "github.com/abitofhelp/servicelib/logging"
)

// MetricsProvider holds the metrics provider and meters
type MetricsProvider struct {
        // provider is the OpenTelemetry meter provider
        provider *sdkmetric.MeterProvider

        // meter is the OpenTelemetry meter
        meter metric.Meter

        // logger is the logger for the metrics provider
        logger *logging.ContextLogger
}

// NewMetricsProvider creates a new metrics provider
//
// Parameters:
//   - ctx: The context for the operation
//   - logger: The logger to use for logging metrics events
//   - k: The koanf instance to load configuration from
//
// Returns:
//   - *MetricsProvider: The metrics provider
//   - error: An error if the metrics provider creation fails
func NewMetricsProvider(ctx context.Context, logger *logging.ContextLogger, k *koanf.Koanf) (*MetricsProvider, error) <span class="cov0" title="0">{
        // Load configuration
        config := LoadConfig(k)
        if !config.Metrics.Enabled </span><span class="cov0" title="0">{
                logger.Info(ctx, "Metrics are disabled")
                return nil, nil
        }</span>

        // Create resource
        <span class="cov0" title="0">res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceNameKey.String(config.ServiceName),
                        semconv.ServiceVersionKey.String(config.Version),
                        attribute.String("environment", config.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // Configure OTLP exporter
        <span class="cov0" title="0">secureOption := otlpmetricgrpc.WithTLSCredentials(insecure.NewCredentials())
        if !config.OTLP.Insecure </span><span class="cov0" title="0">{
                secureOption = otlpmetricgrpc.WithTLSCredentials(nil)
        }</span>

        <span class="cov0" title="0">exporter, err := otlpmetricgrpc.New(ctx,
                otlpmetricgrpc.WithEndpoint(config.OTLP.Endpoint),
                secureOption,
                otlpmetricgrpc.WithDialOption(grpc.WithBlock()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
        }</span>

        // Create meter provider
        <span class="cov0" title="0">reportingInterval := time.Duration(config.Metrics.ReportingFreq) * time.Second
        provider := sdkmetric.NewMeterProvider(
                sdkmetric.WithResource(res),
                sdkmetric.WithReader(
                        sdkmetric.NewPeriodicReader(
                                exporter,
                                sdkmetric.WithInterval(reportingInterval),
                        ),
                ),
        )

        // Set global meter provider
        otel.SetMeterProvider(provider)

        // Create meter with the service name
        meterName := fmt.Sprintf("github.com/abitofhelp/%s", config.ServiceName)
        meter := provider.Meter(meterName)

        logger.Info(ctx, "Metrics provider initialized",
                zap.String("service", config.ServiceName),
                zap.String("environment", config.Environment),
                zap.String("otlp_endpoint", config.OTLP.Endpoint),
                zap.Duration("reporting_interval", reportingInterval),
        )

        return &amp;MetricsProvider{
                provider: provider,
                meter:    meter,
                logger:   logger,
        }, nil</span>
}

// Shutdown shuts down the metrics provider
//
// Parameters:
//   - ctx: The context for the operation
//
// Returns:
//   - error: An error if the shutdown fails
func (mp *MetricsProvider) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if mp.provider == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := mp.provider.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                mp.logger.Error(ctx, "Failed to shutdown metrics provider", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">mp.logger.Info(ctx, "Metrics provider shut down")
        return nil</span>
}

// Meter returns the meter
//
// Returns:
//   - metric.Meter: The OpenTelemetry meter
func (mp *MetricsProvider) Meter() metric.Meter <span class="cov0" title="0">{
        return mp.meter
}</span>

// Common metrics
var (
        // HTTP metrics
        httpRequestsTotal     metric.Int64Counter
        httpRequestDuration   metric.Float64Histogram
        httpRequestsInFlight  metric.Int64UpDownCounter
        httpResponseSizeBytes metric.Int64Histogram

        // Database metrics
        dbOperationsTotal   metric.Int64Counter
        dbOperationDuration metric.Float64Histogram
        dbConnectionsOpen   metric.Int64UpDownCounter

        // Application metrics
        appErrorsTotal metric.Int64Counter
)

// InitCommonMetrics initializes common metrics
//
// Parameters:
//   - mp: The metrics provider
//
// Returns:
//   - error: An error if the metrics initialization fails
func InitCommonMetrics(mp *MetricsProvider) error <span class="cov0" title="0">{
        if mp == nil || mp.meter == nil </span><span class="cov0" title="0">{
                return nil // Metrics are disabled
        }</span>

        <span class="cov0" title="0">var err error

        // Initialize HTTP metrics
        httpRequestsTotal, err = mp.meter.Int64Counter(
                "http.requests.total",
                metric.WithDescription("Total number of HTTP requests"),
                metric.WithUnit("{request}"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create http.requests.total counter: %w", err)
        }</span>

        <span class="cov0" title="0">httpRequestDuration, err = mp.meter.Float64Histogram(
                "http.request.duration",
                metric.WithDescription("HTTP request duration"),
                metric.WithUnit("s"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create http.request.duration histogram: %w", err)
        }</span>

        <span class="cov0" title="0">httpRequestsInFlight, err = mp.meter.Int64UpDownCounter(
                "http.requests.in_flight",
                metric.WithDescription("Number of HTTP requests currently in flight"),
                metric.WithUnit("{request}"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create http.requests.in_flight counter: %w", err)
        }</span>

        <span class="cov0" title="0">httpResponseSizeBytes, err = mp.meter.Int64Histogram(
                "http.response.size",
                metric.WithDescription("HTTP response size in bytes"),
                metric.WithUnit("By"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create http.response.size histogram: %w", err)
        }</span>

        // Initialize database metrics
        <span class="cov0" title="0">dbOperationsTotal, err = mp.meter.Int64Counter(
                "db.operations.total",
                metric.WithDescription("Total number of database operations"),
                metric.WithUnit("{operation}"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create db.operations.total counter: %w", err)
        }</span>

        <span class="cov0" title="0">dbOperationDuration, err = mp.meter.Float64Histogram(
                "db.operation.duration",
                metric.WithDescription("Database operation duration"),
                metric.WithUnit("s"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create db.operation.duration histogram: %w", err)
        }</span>

        <span class="cov0" title="0">dbConnectionsOpen, err = mp.meter.Int64UpDownCounter(
                "db.connections.open",
                metric.WithDescription("Number of open database connections"),
                metric.WithUnit("{connection}"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create db.connections.open counter: %w", err)
        }</span>

        // Initialize application metrics
        <span class="cov0" title="0">appErrorsTotal, err = mp.meter.Int64Counter(
                "app.errors.total",
                metric.WithDescription("Total number of application errors"),
                metric.WithUnit("{error}"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create app.errors.total counter: %w", err)
        }</span>

        <span class="cov0" title="0">mp.logger.Info(context.Background(), "Common metrics initialized")
        return nil</span>
}

// RecordHTTPRequest records metrics for an HTTP request
//
// Parameters:
//   - ctx: The context for the operation
//   - method: The HTTP method
//   - path: The HTTP path
//   - statusCode: The HTTP status code
//   - duration: The request duration
//   - responseSize: The response size in bytes
func RecordHTTPRequest(ctx context.Context, method, path string, statusCode int, duration time.Duration, responseSize int64) <span class="cov0" title="0">{
        if httpRequestsTotal != nil </span><span class="cov0" title="0">{
                httpRequestsTotal.Add(ctx, 1,
                        metric.WithAttributes(
                                attribute.String("method", method),
                                attribute.String("path", path),
                                attribute.Int("status_code", statusCode),
                        ),
                )
        }</span>

        <span class="cov0" title="0">if httpRequestDuration != nil </span><span class="cov0" title="0">{
                httpRequestDuration.Record(ctx, duration.Seconds(),
                        metric.WithAttributes(
                                attribute.String("method", method),
                                attribute.String("path", path),
                                attribute.Int("status_code", statusCode),
                        ),
                )
        }</span>

        <span class="cov0" title="0">if httpResponseSizeBytes != nil </span><span class="cov0" title="0">{
                httpResponseSizeBytes.Record(ctx, responseSize,
                        metric.WithAttributes(
                                attribute.String("method", method),
                                attribute.String("path", path),
                                attribute.Int("status_code", statusCode),
                        ),
                )
        }</span>
}

// IncrementRequestsInFlight increments the in-flight requests counter
//
// Parameters:
//   - ctx: The context for the operation
//   - method: The HTTP method
//   - path: The HTTP path
func IncrementRequestsInFlight(ctx context.Context, method, path string) <span class="cov0" title="0">{
        if httpRequestsInFlight != nil </span><span class="cov0" title="0">{
                httpRequestsInFlight.Add(ctx, 1,
                        metric.WithAttributes(
                                attribute.String("method", method),
                                attribute.String("path", path),
                        ),
                )
        }</span>
}

// DecrementRequestsInFlight decrements the in-flight requests counter
//
// Parameters:
//   - ctx: The context for the operation
//   - method: The HTTP method
//   - path: The HTTP path
func DecrementRequestsInFlight(ctx context.Context, method, path string) <span class="cov0" title="0">{
        if httpRequestsInFlight != nil </span><span class="cov0" title="0">{
                httpRequestsInFlight.Add(ctx, -1,
                        metric.WithAttributes(
                                attribute.String("method", method),
                                attribute.String("path", path),
                        ),
                )
        }</span>
}

// RecordDBOperation records metrics for a database operation
//
// Parameters:
//   - ctx: The context for the operation
//   - operation: The database operation
//   - database: The database name
//   - collection: The collection or table name
//   - duration: The operation duration
//   - err: The error if the operation failed
func RecordDBOperation(ctx context.Context, operation, database, collection string, duration time.Duration, err error) <span class="cov0" title="0">{
        if dbOperationsTotal != nil </span><span class="cov0" title="0">{
                dbOperationsTotal.Add(ctx, 1,
                        metric.WithAttributes(
                                attribute.String("operation", operation),
                                attribute.String("database", database),
                                attribute.String("collection", collection),
                                attribute.Bool("success", err == nil),
                        ),
                )
        }</span>

        <span class="cov0" title="0">if dbOperationDuration != nil </span><span class="cov0" title="0">{
                dbOperationDuration.Record(ctx, duration.Seconds(),
                        metric.WithAttributes(
                                attribute.String("operation", operation),
                                attribute.String("database", database),
                                attribute.String("collection", collection),
                                attribute.Bool("success", err == nil),
                        ),
                )
        }</span>

        <span class="cov0" title="0">if err != nil &amp;&amp; appErrorsTotal != nil </span><span class="cov0" title="0">{
                appErrorsTotal.Add(ctx, 1,
                        metric.WithAttributes(
                                attribute.String("type", "database"),
                                attribute.String("operation", operation),
                                attribute.String("database", database),
                                attribute.String("collection", collection),
                        ),
                )
        }</span>
}

// UpdateDBConnections updates the open database connections counter
//
// Parameters:
//   - ctx: The context for the operation
//   - database: The database name
//   - delta: The change in the number of connections
func UpdateDBConnections(ctx context.Context, database string, delta int64) <span class="cov0" title="0">{
        if dbConnectionsOpen != nil </span><span class="cov0" title="0">{
                dbConnectionsOpen.Add(ctx, delta,
                        metric.WithAttributes(
                                attribute.String("database", database),
                        ),
                )
        }</span>
}

// RecordErrorMetric records an application error in metrics
//
// Parameters:
//   - ctx: The context for the operation
//   - errorType: The type of error
//   - operation: The operation that failed
func RecordErrorMetric(ctx context.Context, errorType, operation string) <span class="cov0" title="0">{
        if appErrorsTotal != nil </span><span class="cov0" title="0">{
                appErrorsTotal.Add(ctx, 1,
                        metric.WithAttributes(
                                attribute.String("type", errorType),
                                attribute.String("operation", operation),
                        ),
                )
        }</span>
}

// IsMetricsEnabled returns whether metrics are enabled
//
// Parameters:
//   - k: The koanf instance to load configuration from
//
// Returns:
//   - bool: Whether metrics are enabled
func IsMetricsEnabled(k *koanf.Koanf) bool <span class="cov0" title="0">{
        return k.Bool("telemetry.metrics.enabled")
}</span>

// CreatePrometheusHandler creates a handler for the /metrics endpoint
//
// Returns:
//   - http.Handler: The Prometheus metrics handler
func CreatePrometheusHandler() http.Handler <span class="cov0" title="0">{
        // Create a new registry
        registry := prometheus.NewRegistry()

        // Register the Go collector which collects runtime metrics
        registry.MustRegister(prometheus.NewGoCollector())

        // Register the process collector which collects process metrics
        registry.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))

        // Create a handler for the registry
        return promhttp.HandlerFor(registry, promhttp.HandlerOpts{
                EnableOpenMetrics: true,
        })
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package tracing provides functionality for distributed tracing in applications.
package tracing

import (
        "net/http"

        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.uber.org/zap"

        "github.com/abitofhelp/servicelib/logging"
)

// InstrumentHandler wraps an http.Handler with OpenTelemetry instrumentation.
// This adds tracing to all HTTP requests handled by the provided handler.
//
// Parameters:
//   - handler: The HTTP handler to instrument
//   - operation: The name of the operation for tracing
//   - opts: Additional options for the instrumentation
//
// Returns:
//   - http.Handler: The instrumented HTTP handler
func InstrumentHandler(handler http.Handler, operation string, opts ...otelhttp.Option) http.Handler <span class="cov0" title="0">{
        return otelhttp.NewHandler(handler, operation, opts...)
}</span>

// InstrumentClient wraps an http.Client with OpenTelemetry instrumentation.
// This adds tracing to all HTTP requests made by the provided client.
//
// Parameters:
//   - client: The HTTP client to instrument
//   - opts: Additional options for the instrumentation
//
// Returns:
//   - *http.Client: The instrumented HTTP client
func InstrumentClient(client *http.Client, opts ...otelhttp.Option) *http.Client <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                client = http.DefaultClient
        }</span>

        <span class="cov0" title="0">client.Transport = otelhttp.NewTransport(
                client.Transport,
                opts...,
        )

        return client</span>
}

// NewHTTPMiddleware creates a new middleware for HTTP request tracing.
// This middleware adds tracing to all HTTP requests and logs request information.
//
// Parameters:
//   - logger: The logger to use for logging request information
//
// Returns:
//   - func(http.Handler) http.Handler: The middleware function
func NewHTTPMiddleware(logger *logging.ContextLogger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        tracer := otel.Tracer("github.com/abitofhelp/servicelib/tracing.http")

        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx, span := tracer.Start(r.Context(), r.Method+" "+r.URL.Path)
                        defer span.End()

                        // Add common attributes to the span
                        span.SetAttributes(
                                attribute.String("http.method", r.Method),
                                attribute.String("http.url", r.URL.String()),
                                attribute.String("http.host", r.Host),
                                attribute.String("http.user_agent", r.UserAgent()),
                        )

                        // Add trace ID to response headers for debugging
                        traceID := span.SpanContext().TraceID().String()
                        w.Header().Set("X-Trace-ID", traceID)

                        // Log request with trace ID
                        logger.Info(ctx, "HTTP request",
                                zap.String("method", r.Method),
                                zap.String("path", r.URL.Path),
                                zap.String("trace_id", traceID),
                        )

                        // Call the next handler with the updated context
                        next.ServeHTTP(w, r.WithContext(ctx))
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package tracing provides functionality for distributed tracing in applications.
package tracing

import (
        "context"
        "net/http"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/metric"
        "go.uber.org/zap"

        "github.com/abitofhelp/servicelib/logging"
)

// MetricsConfig holds configuration for metrics
type MetricsConfig struct {
        // Enabled indicates whether metrics are enabled
        Enabled bool

        // ServiceName is the name of the service
        ServiceName string

        // Environment is the environment the service is running in
        Environment string

        // Version is the version of the service
        Version string

        // PrometheusEnabled indicates whether Prometheus metrics are enabled
        PrometheusEnabled bool

        // PrometheusPath is the path to expose Prometheus metrics on
        PrometheusPath string
}

// MetricsProvider holds the metrics provider and meters
type MetricsProvider struct {
        // meter is the OpenTelemetry meter
        meter metric.Meter

        // logger is the logger for the metrics provider
        logger *logging.ContextLogger

        // config is the metrics configuration
        config MetricsConfig
}

// NewMetricsProvider creates a new metrics provider
//
// Parameters:
//   - ctx: The context for the operation
//   - logger: The logger to use for logging metrics events
//   - config: The metrics configuration
//   - meter: The OpenTelemetry meter
//
// Returns:
//   - *MetricsProvider: The metrics provider
func NewMetricsProvider(ctx context.Context, logger *logging.ContextLogger, config MetricsConfig, meter metric.Meter) *MetricsProvider <span class="cov0" title="0">{
        if !config.Enabled </span><span class="cov0" title="0">{
                logger.Info(ctx, "Metrics are disabled")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Info(ctx, "Metrics provider initialized",
                zap.String("service", config.ServiceName),
                zap.String("environment", config.Environment),
                zap.Bool("prometheus_enabled", config.PrometheusEnabled),
        )

        return &amp;MetricsProvider{
                meter:  meter,
                logger: logger,
                config: config,
        }</span>
}

// Meter returns the meter
//
// Returns:
//   - metric.Meter: The OpenTelemetry meter
func (mp *MetricsProvider) Meter() metric.Meter <span class="cov0" title="0">{
        return mp.meter
}</span>

// CreateCounter creates a new counter metric
//
// Parameters:
//   - name: The name of the counter
//   - description: The description of the counter
//   - unit: The unit of the counter
//
// Returns:
//   - metric.Int64Counter: The counter
//   - error: An error if the counter creation fails
func (mp *MetricsProvider) CreateCounter(name, description, unit string) (metric.Int64Counter, error) <span class="cov0" title="0">{
        return mp.meter.Int64Counter(
                name,
                metric.WithDescription(description),
                metric.WithUnit(unit),
        )
}</span>

// CreateHistogram creates a new histogram metric
//
// Parameters:
//   - name: The name of the histogram
//   - description: The description of the histogram
//   - unit: The unit of the histogram
//
// Returns:
//   - metric.Float64Histogram: The histogram
//   - error: An error if the histogram creation fails
func (mp *MetricsProvider) CreateHistogram(name, description, unit string) (metric.Float64Histogram, error) <span class="cov0" title="0">{
        return mp.meter.Float64Histogram(
                name,
                metric.WithDescription(description),
                metric.WithUnit(unit),
        )
}</span>

// CreateUpDownCounter creates a new up/down counter metric
//
// Parameters:
//   - name: The name of the counter
//   - description: The description of the counter
//   - unit: The unit of the counter
//
// Returns:
//   - metric.Int64UpDownCounter: The counter
//   - error: An error if the counter creation fails
func (mp *MetricsProvider) CreateUpDownCounter(name, description, unit string) (metric.Int64UpDownCounter, error) <span class="cov0" title="0">{
        return mp.meter.Int64UpDownCounter(
                name,
                metric.WithDescription(description),
                metric.WithUnit(unit),
        )
}</span>

// RecordDuration records a duration metric
//
// Parameters:
//   - ctx: The context for the operation
//   - histogram: The histogram to record to
//   - duration: The duration to record
//   - attrs: The attributes to record with the duration
func RecordDuration(ctx context.Context, histogram metric.Float64Histogram, duration time.Duration, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if histogram != nil </span><span class="cov0" title="0">{
                histogram.Record(ctx, duration.Seconds(), metric.WithAttributes(attrs...))
        }</span>
}

// IncrementCounter increments a counter metric
//
// Parameters:
//   - ctx: The context for the operation
//   - counter: The counter to increment
//   - value: The value to increment by
//   - attrs: The attributes to record with the increment
func IncrementCounter(ctx context.Context, counter metric.Int64Counter, value int64, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if counter != nil </span><span class="cov0" title="0">{
                counter.Add(ctx, value, metric.WithAttributes(attrs...))
        }</span>
}

// UpdateUpDownCounter updates an up/down counter metric
//
// Parameters:
//   - ctx: The context for the operation
//   - counter: The counter to update
//   - value: The value to update by
//   - attrs: The attributes to record with the update
func UpdateUpDownCounter(ctx context.Context, counter metric.Int64UpDownCounter, value int64, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if counter != nil </span><span class="cov0" title="0">{
                counter.Add(ctx, value, metric.WithAttributes(attrs...))
        }</span>
}

// CreatePrometheusHandler creates a handler for the Prometheus metrics endpoint
//
// Returns:
//   - http.Handler: The Prometheus metrics handler
func CreatePrometheusHandler() http.Handler <span class="cov0" title="0">{
        // Create a new registry
        registry := prometheus.NewRegistry()

        // Register the Go collector which collects runtime metrics
        registry.MustRegister(prometheus.NewGoCollector())

        // Register the process collector which collects process metrics
        registry.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))

        // Create a handler for the registry
        return promhttp.HandlerFor(registry, promhttp.HandlerOpts{
                EnableOpenMetrics: true,
        })
}</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package tracing provides functionality for distributed tracing in applications.
package tracing

import (
        "context"
        "net/http"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/metric"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"

        "github.com/abitofhelp/servicelib/logging"
)

// TelemetryProvider is a unified provider for tracing and metrics
type TelemetryProvider struct {
        // tracingProvider is the tracing provider
        tracingProvider *TracingProvider

        // metricsProvider is the metrics provider
        metricsProvider *MetricsProvider

        // logger is the logger for the telemetry provider
        logger *logging.ContextLogger
}

// TelemetryConfig holds configuration for telemetry
type TelemetryConfig struct {
        // Enabled indicates whether telemetry is enabled
        Enabled bool

        // ServiceName is the name of the service
        ServiceName string

        // Environment is the environment the service is running in
        Environment string

        // Version is the version of the service
        Version string

        // Tracing is the configuration for tracing
        Tracing struct {
                // Enabled indicates whether tracing is enabled
                Enabled bool

                // SamplingRatio is the ratio of traces to sample
                SamplingRatio float64

                // PropagationKeys are the keys to propagate in trace context
                PropagationKeys []string

                // OTLPEndpoint is the OTLP endpoint
                OTLPEndpoint string

                // OTLPInsecure indicates whether to use insecure connections
                OTLPInsecure bool

                // OTLPTimeout is the timeout for OTLP operations in seconds
                OTLPTimeout int

                // ShutdownTimeout is the timeout for shutting down tracing in seconds
                ShutdownTimeout int
        }

        // Metrics is the configuration for metrics
        Metrics struct {
                // Enabled indicates whether metrics are enabled
                Enabled bool

                // Prometheus is the configuration for Prometheus metrics
                Prometheus struct {
                        // Enabled indicates whether Prometheus metrics are enabled
                        Enabled bool

                        // Path is the path to expose Prometheus metrics on
                        Path string
                }
        }
}

// NewTelemetryProvider creates a new telemetry provider
//
// Parameters:
//   - ctx: The context for the operation
//   - logger: The logger to use for logging telemetry events
//   - config: The telemetry configuration
//
// Returns:
//   - *TelemetryProvider: The telemetry provider
//   - error: An error if the telemetry provider creation fails
func NewTelemetryProvider(ctx context.Context, logger *logging.ContextLogger, config TelemetryConfig) (*TelemetryProvider, error) <span class="cov0" title="0">{
        if !config.Enabled </span><span class="cov0" title="0">{
                logger.Info(ctx, "Telemetry is disabled")
                return nil, nil
        }</span>

        // Create tracing provider
        <span class="cov0" title="0">tracingConfig := Config{
                Enabled:         config.Tracing.Enabled,
                ServiceName:     config.ServiceName,
                Environment:     config.Environment,
                Version:         config.Version,
                SamplingRatio:   config.Tracing.SamplingRatio,
                PropagationKeys: config.Tracing.PropagationKeys,
                OTLPEndpoint:    config.Tracing.OTLPEndpoint,
                OTLPInsecure:    config.Tracing.OTLPInsecure,
                OTLPTimeout:     config.Tracing.OTLPTimeout,
                ShutdownTimeout: config.Tracing.ShutdownTimeout,
        }

        tracingProvider, err := NewTracingProvider(ctx, logger, tracingConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create metrics provider
        <span class="cov0" title="0">metricsConfig := MetricsConfig{
                Enabled:          config.Metrics.Enabled,
                ServiceName:      config.ServiceName,
                Environment:      config.Environment,
                Version:          config.Version,
                PrometheusEnabled: config.Metrics.Prometheus.Enabled,
                PrometheusPath:   config.Metrics.Prometheus.Path,
        }

        // Create meter
        meter := otel.Meter("github.com/abitofhelp/servicelib/tracing")

        metricsProvider := NewMetricsProvider(ctx, logger, metricsConfig, meter)

        logger.Info(ctx, "Telemetry provider initialized",
                zap.String("service", config.ServiceName),
                zap.String("environment", config.Environment),
                zap.Bool("tracing_enabled", config.Tracing.Enabled),
                zap.Bool("metrics_enabled", config.Metrics.Enabled),
        )

        return &amp;TelemetryProvider{
                tracingProvider: tracingProvider,
                metricsProvider: metricsProvider,
                logger:          logger,
        }, nil</span>
}

// Shutdown shuts down the telemetry provider
//
// Parameters:
//   - ctx: The context for the operation
//
// Returns:
//   - error: An error if the shutdown fails
func (tp *TelemetryProvider) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if tp.tracingProvider != nil </span><span class="cov0" title="0">{
                if err := tp.tracingProvider.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Tracer returns the tracer
//
// Returns:
//   - trace.Tracer: The OpenTelemetry tracer
func (tp *TelemetryProvider) Tracer() trace.Tracer <span class="cov0" title="0">{
        if tp.tracingProvider != nil </span><span class="cov0" title="0">{
                return tp.tracingProvider.Tracer()
        }</span>
        <span class="cov0" title="0">return otel.Tracer("github.com/abitofhelp/servicelib/tracing")</span>
}

// Meter returns the meter
//
// Returns:
//   - metric.Meter: The OpenTelemetry meter
func (tp *TelemetryProvider) Meter() metric.Meter <span class="cov0" title="0">{
        if tp.metricsProvider != nil </span><span class="cov0" title="0">{
                return tp.metricsProvider.Meter()
        }</span>
        <span class="cov0" title="0">return otel.Meter("github.com/abitofhelp/servicelib/tracing")</span>
}

// CreatePrometheusHandler creates a handler for the Prometheus metrics endpoint
//
// Returns:
//   - http.Handler: The Prometheus metrics handler
func (tp *TelemetryProvider) CreatePrometheusHandler() http.Handler <span class="cov0" title="0">{
        return CreatePrometheusHandler()
}</span>

// InstrumentHandler wraps an http.Handler with OpenTelemetry instrumentation
//
// Parameters:
//   - handler: The HTTP handler to instrument
//   - operation: The name of the operation for tracing
//
// Returns:
//   - http.Handler: The instrumented HTTP handler
func (tp *TelemetryProvider) InstrumentHandler(handler http.Handler, operation string) http.Handler <span class="cov0" title="0">{
        return InstrumentHandler(handler, operation)
}</span>

// NewHTTPMiddleware creates a new middleware for HTTP request tracing
//
// Returns:
//   - func(http.Handler) http.Handler: The middleware function
func (tp *TelemetryProvider) NewHTTPMiddleware() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return NewHTTPMiddleware(tp.logger)
}</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package tracing provides functionality for distributed tracing in applications.
package tracing

import (
        "context"
        "fmt"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "github.com/abitofhelp/servicelib/logging"
)

// TracingProvider holds the tracing provider and tracer
type TracingProvider struct {
        // provider is the OpenTelemetry tracer provider
        provider *sdktrace.TracerProvider

        // tracer is the OpenTelemetry tracer
        tracer trace.Tracer

        // logger is the logger for the tracing provider
        logger *logging.ContextLogger
}

// Config holds configuration for tracing
type Config struct {
        // Enabled indicates whether tracing is enabled
        Enabled bool

        // ServiceName is the name of the service
        ServiceName string

        // Environment is the environment the service is running in
        Environment string

        // Version is the version of the service
        Version string

        // SamplingRatio is the ratio of traces to sample
        SamplingRatio float64

        // PropagationKeys are the keys to propagate in trace context
        PropagationKeys []string

        // OTLPEndpoint is the OTLP endpoint
        OTLPEndpoint string

        // OTLPInsecure indicates whether to use insecure connections
        OTLPInsecure bool

        // OTLPTimeout is the timeout for OTLP operations in seconds
        OTLPTimeout int

        // ShutdownTimeout is the timeout for shutting down tracing in seconds
        ShutdownTimeout int
}

// NewTracingProvider creates a new tracing provider
//
// Parameters:
//   - ctx: The context for the operation
//   - logger: The logger to use for logging tracing events
//   - config: The tracing configuration
//
// Returns:
//   - *TracingProvider: The tracing provider
//   - error: An error if the tracing provider creation fails
func NewTracingProvider(ctx context.Context, logger *logging.ContextLogger, config Config) (*TracingProvider, error) <span class="cov0" title="0">{
        if !config.Enabled </span><span class="cov0" title="0">{
                logger.Info(ctx, "Tracing is disabled")
                return nil, nil
        }</span>

        // Create resource
        <span class="cov0" title="0">res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceNameKey.String(config.ServiceName),
                        semconv.ServiceVersionKey.String(config.Version),
                        attribute.String("environment", config.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // Configure OTLP exporter
        <span class="cov0" title="0">secureOption := otlptracegrpc.WithTLSCredentials(insecure.NewCredentials())
        if !config.OTLPInsecure </span><span class="cov0" title="0">{
                secureOption = otlptracegrpc.WithTLSCredentials(nil)
        }</span>

        <span class="cov0" title="0">exporter, err := otlptracegrpc.New(ctx,
                otlptracegrpc.WithEndpoint(config.OTLPEndpoint),
                secureOption,
                otlptracegrpc.WithDialOption(grpc.WithBlock()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
        }</span>

        // Create tracer provider
        <span class="cov0" title="0">provider := sdktrace.NewTracerProvider(
                sdktrace.WithResource(res),
                sdktrace.WithBatcher(exporter),
                sdktrace.WithSampler(sdktrace.TraceIDRatioBased(config.SamplingRatio)),
        )

        // Set global tracer provider
        otel.SetTracerProvider(provider)

        // Set global propagator
        propagator := propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        )
        otel.SetTextMapPropagator(propagator)

        // Create tracer
        tracer := provider.Tracer("github.com/abitofhelp/servicelib/tracing")

        logger.Info(ctx, "Tracing provider initialized",
                zap.String("service", config.ServiceName),
                zap.String("environment", config.Environment),
                zap.String("otlp_endpoint", config.OTLPEndpoint),
                zap.Float64("sampling_ratio", config.SamplingRatio),
        )

        return &amp;TracingProvider{
                provider: provider,
                tracer:   tracer,
                logger:   logger,
        }, nil</span>
}

// Shutdown shuts down the tracing provider
//
// Parameters:
//   - ctx: The context for the operation
//
// Returns:
//   - error: An error if the shutdown fails
func (tp *TracingProvider) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if tp.provider == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := tp.provider.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                tp.logger.Error(ctx, "Failed to shutdown tracing provider", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">tp.logger.Info(ctx, "Tracing provider shut down")
        return nil</span>
}

// Tracer returns the tracer
//
// Returns:
//   - trace.Tracer: The OpenTelemetry tracer
func (tp *TracingProvider) Tracer() trace.Tracer <span class="cov0" title="0">{
        return tp.tracer
}</span>

// StartSpan is a helper function to start a new span from a context.
// This is useful for tracing operations within a request.
//
// Parameters:
//   - ctx: The context to start the span from
//   - name: The name of the span
//
// Returns:
//   - context.Context: The context with the span
//   - trace.Span: The span
func StartSpan(ctx context.Context, name string) (context.Context, trace.Span) <span class="cov0" title="0">{
        tracer := otel.Tracer("github.com/abitofhelp/servicelib/tracing")
        return tracer.Start(ctx, name)
}</span>

// AddSpanAttributes adds attributes to the current span in context.
// This is useful for adding additional information to a span.
//
// Parameters:
//   - ctx: The context containing the span
//   - attrs: The attributes to add to the span
func AddSpanAttributes(ctx context.Context, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        span.SetAttributes(attrs...)
}</span>

// RecordError records an error on the current span in context.
// This is useful for recording errors that occur during a traced operation.
//
// Parameters:
//   - ctx: The context containing the span
//   - err: The error to record
//   - opts: Additional options for the error event
func RecordError(ctx context.Context, err error, opts ...trace.EventOption) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                span := trace.SpanFromContext(ctx)
                span.RecordError(err, opts...)
        }</span>
}

// WithSpan wraps a function with a span.
// This is useful for tracing functions.
//
// Parameters:
//   - ctx: The context to start the span from
//   - name: The name of the span
//   - fn: The function to wrap
//
// Returns:
//   - error: The error returned by the function
func WithSpan(ctx context.Context, name string, fn func(context.Context) error) error <span class="cov0" title="0">{
        ctx, span := StartSpan(ctx, name)
        defer span.End()

        return fn(ctx)
}</span>

// WithSpanTimed wraps a function with a span and records the execution time.
// This is useful for tracing functions and measuring their execution time.
//
// Parameters:
//   - ctx: The context to start the span from
//   - name: The name of the span
//   - fn: The function to wrap
//
// Returns:
//   - time.Duration: The execution time of the function
//   - error: The error returned by the function
func WithSpanTimed(ctx context.Context, name string, fn func(context.Context) error) (time.Duration, error) <span class="cov0" title="0">{
        ctx, span := StartSpan(ctx, name)
        defer span.End()

        start := time.Now()
        err := fn(ctx)
        duration := time.Since(start)

        span.SetAttributes(attribute.Float64("duration_ms", float64(duration.Milliseconds())))
        if err != nil </span><span class="cov0" title="0">{
                RecordError(ctx, err)
        }</span>

        <span class="cov0" title="0">return duration, err</span>
}</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

// Package saga provides utilities for implementing the saga pattern for distributed transactions.
package saga

import (
        "context"
        "go.uber.org/zap"

 appctx "github.com/abitofhelp/servicelib/context"
 "github.com/abitofhelp/servicelib/errors"
 "github.com/abitofhelp/servicelib/logging"
)

// Operation represents a function that performs a database operation.
type Operation func(ctx context.Context) error

// RollbackOperation represents a function that rolls back a database operation.
type RollbackOperation func(ctx context.Context) error

// Transaction represents a transaction that can be executed and rolled back.
type Transaction struct {
        operations []Operation
        rollbacks  []RollbackOperation
        logger     *logging.ContextLogger
}

// NewTransaction creates a new transaction.
//
// Parameters:
//   - logger: The logger to use for logging transaction events
//
// Returns:
//   - *Transaction: A new transaction instance
func NewTransaction(logger *zap.Logger) *Transaction <span class="cov0" title="0">{
        var contextLogger *logging.ContextLogger
        if logger == nil </span><span class="cov0" title="0">{
                // Create a default logger with info level in development mode
                defaultLogger, _ := logging.NewLogger("info", true)
                contextLogger = logging.NewContextLogger(defaultLogger)
        }</span> else<span class="cov0" title="0"> {
                contextLogger = logging.NewContextLogger(logger)
        }</span>
        <span class="cov0" title="0">return &amp;Transaction{
                operations: make([]Operation, 0),
                rollbacks:  make([]RollbackOperation, 0),
                logger:     contextLogger,
        }</span>
}

// AddOperation adds an operation to the transaction with its corresponding rollback operation.
//
// Parameters:
//   - op: The operation to execute
//   - rollback: The rollback operation to execute if the transaction fails
func (t *Transaction) AddOperation(op Operation, rollback RollbackOperation) <span class="cov0" title="0">{
        t.operations = append(t.operations, op)
        t.rollbacks = append(t.rollbacks, rollback)
}</span>

// Execute executes all operations in the transaction. If any operation fails,
// it rolls back all previously executed operations in reverse order.
//
// Parameters:
//   - ctx: The context for the operation
//
// Returns:
//   - error: An error if the transaction fails
func (t *Transaction) Execute(ctx context.Context) error <span class="cov0" title="0">{
        // Check if context is done
        if err := appctx.CheckContext(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.WrapWithOperation(err, "Transaction.Execute", "transaction execution aborted")
        }</span>

        // Validate that operations and rollbacks have the same length
        <span class="cov0" title="0">if len(t.operations) != len(t.rollbacks) </span><span class="cov0" title="0">{
                return errors.Internal(nil, "transaction operations and rollbacks count mismatch")
        }</span>

        <span class="cov0" title="0">for i, op := range t.operations </span><span class="cov0" title="0">{
                // Check context before each operation
                if err := appctx.CheckContext(ctx); err != nil </span><span class="cov0" title="0">{
                        rollbackErrors := t.rollback(ctx, i-1)

                        // Add rollback errors as details to the context error
                        if len(rollbackErrors) &gt; 0 </span><span class="cov0" title="0">{
                                details := map[string]interface{}{
                                        "operation_index": i,
                                        "rollback_errors": rollbackErrors,
                                }
                                return errors.WithDetails(
                                        errors.WrapWithOperation(err, "Transaction.Execute", "transaction operation aborted"),
                                        details,
                                )
                        }</span>

                        <span class="cov0" title="0">return errors.WrapWithOperation(err, "Transaction.Execute", "transaction operation aborted")</span>
                }

                <span class="cov0" title="0">if err := op(ctx); err != nil </span><span class="cov0" title="0">{
                        // Roll back all previously executed operations in reverse order
                        rollbackErrors := t.rollback(ctx, i-1)

                        // Add operation index and rollback errors as details
                        details := map[string]interface{}{
                                "operation_index":  i,
                                "failed_operation": i,
                        }

                        if len(rollbackErrors) &gt; 0 </span><span class="cov0" title="0">{
                                details["rollback_errors"] = rollbackErrors
                        }</span>

                        <span class="cov0" title="0">return errors.WithDetails(
                                errors.WrapWithOperation(err, "Transaction.Execute", "transaction operation failed"),
                                details,
                        )</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// rollback rolls back operations from index i down to 0 and returns any errors.
func (t *Transaction) rollback(ctx context.Context, i int) []error <span class="cov0" title="0">{
        var errors []error
        for j := i; j &gt;= 0; j-- </span><span class="cov0" title="0">{
                if err := t.rollbacks[j](ctx); err != nil </span><span class="cov0" title="0">{
                        t.logger.Error(ctx, "Failed to rollback operation", zap.Error(err))
                        errors = append(errors, err)
                }</span>
        }
        <span class="cov0" title="0">return errors</span>
}

// WithTransaction executes a function within a transaction and handles rollback if needed.
//
// Parameters:
//   - ctx: The context for the operation
//   - logger: The logger to use for logging transaction events
//   - fn: The function to execute within the transaction
//
// Returns:
//   - error: An error if the transaction fails
func WithTransaction(ctx context.Context, logger *zap.Logger, fn func(tx *Transaction) error) error <span class="cov0" title="0">{
        // Check if context is done
        if err := appctx.CheckContext(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.WrapWithOperation(err, "WithTransaction", "transaction creation aborted")
        }</span>

        <span class="cov0" title="0">tx := NewTransaction(logger)
        if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                // Add operation information to the error
                return errors.WrapWithOperation(err, "WithTransaction", "transaction setup failed")
        }</span>

        // Execute the transaction
        <span class="cov0" title="0">if err := tx.Execute(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.WrapWithOperation(err, "WithTransaction", "transaction execution failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NoopRollback returns a rollback operation that does nothing.
//
// Returns:
//   - RollbackOperation: A rollback operation that does nothing
func NoopRollback() RollbackOperation <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                return nil
        }</span>
}

// CheckedRollback wraps a rollback operation with error checking.
//
// Parameters:
//   - rollback: The rollback operation to wrap
//   - operation: The name of the operation
//   - errorMsg: The error message to use if the rollback fails
//
// Returns:
//   - RollbackOperation: A wrapped rollback operation
func CheckedRollback(rollback RollbackOperation, operation string, errorMsg string) RollbackOperation <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                if err := rollback(ctx); err != nil </span><span class="cov0" title="0">{
                        return errors.WrapWithOperation(err, operation, errorMsg)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// CheckedRollbackWithDetails wraps a rollback operation with error checking and additional details.
//
// Parameters:
//   - rollback: The rollback operation to wrap
//   - operation: The name of the operation
//   - errorMsg: The error message to use if the rollback fails
//   - details: Additional details to add to the error
//
// Returns:
//   - RollbackOperation: A wrapped rollback operation
func CheckedRollbackWithDetails(rollback RollbackOperation, operation string, errorMsg string, details map[string]interface{}) RollbackOperation <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                if err := rollback(ctx); err != nil </span><span class="cov0" title="0">{
                        wrappedErr := errors.WrapWithOperation(err, operation, errorMsg)
                        return errors.WithDetails(wrappedErr, details)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright (c) 2025 A Bit of Help, Inc.

package validation

import (
        "regexp"
        "strings"
        "time"

        "github.com/abitofhelp/servicelib/errors"
)

// ValidationResult holds the result of a validation operation
type ValidationResult struct {
        errors *errors.ValidationErrors
}

// NewValidationResult creates a new ValidationResult
func NewValidationResult() *ValidationResult <span class="cov9" title="29">{
        return &amp;ValidationResult{
                errors: errors.NewValidationErrors(),
        }
}</span>

// AddError adds an error to the validation result
func (v *ValidationResult) AddError(msg, field string) <span class="cov7" title="15">{
        v.errors.AddError(errors.NewFieldValidationError(msg, field))
}</span>

// IsValid returns true if there are no validation errors
func (v *ValidationResult) IsValid() bool <span class="cov10" title="33">{
        return !v.errors.HasErrors()
}</span>

// Error returns the validation errors as an error
func (v *ValidationResult) Error() error <span class="cov4" title="4">{
        if v.IsValid() </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov2" title="2">return v.errors</span>
}

// Required validates that a string is not empty
func Required(value, field string, result *ValidationResult) <span class="cov3" title="3">{
        if strings.TrimSpace(value) == "" </span><span class="cov2" title="2">{
                result.AddError("is required", field)
        }</span>
}

// MinLength validates that a string has a minimum length
func MinLength(value string, min int, field string, result *ValidationResult) <span class="cov4" title="4">{
        if len(value) &lt; min </span><span class="cov2" title="2">{
                result.AddError(
                        "must be at least "+string(rune('0'+min))+" characters long",
                        field,
                )
        }</span>
}

// MaxLength validates that a string has a maximum length
func MaxLength(value string, max int, field string, result *ValidationResult) <span class="cov4" title="4">{
        if len(value) &gt; max </span><span class="cov1" title="1">{
                result.AddError(
                        "must be at most "+string(rune('0'+max))+" characters long",
                        field,
                )
        }</span>
}

// Pattern validates that a string matches a regular expression
func Pattern(value, pattern, field string, result *ValidationResult) <span class="cov3" title="3">{
        matched, _ := regexp.MatchString(pattern, value)
        if !matched </span><span class="cov2" title="2">{
                result.AddError("has an invalid format", field)
        }</span>
}

// PastDate validates that a date is in the past
func PastDate(value time.Time, field string, result *ValidationResult) <span class="cov2" title="2">{
        if value.After(time.Now()) </span><span class="cov1" title="1">{
                result.AddError("must be in the past", field)
        }</span>
}

// ValidDateRange validates that a start date is before an end date
func ValidDateRange(start, end time.Time, startField, endField string, result *ValidationResult) <span class="cov3" title="3">{
        if !end.IsZero() &amp;&amp; start.After(end) </span><span class="cov1" title="1">{
                result.AddError("must be before "+endField, startField)
        }</span>
}

// AllTrue validates that all items in a slice satisfy a predicate
func AllTrue[T any](items []T, predicate func(T) bool) bool <span class="cov3" title="3">{
        for _, item := range items </span><span class="cov5" title="6">{
                if !predicate(item) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov2" title="2">return true</span>
}

// ValidateAll validates all items in a slice
func ValidateAll[T any](items []T, validator func(T, int, *ValidationResult), result *ValidationResult) <span class="cov3" title="3">{
        for i, item := range items </span><span class="cov5" title="6">{
                validator(item, i, result)
        }</span>
}

// ValidateID validates that an ID is not empty
func ValidateID(id, field string, result *ValidationResult) <span class="cov3" title="3">{
        if strings.TrimSpace(id) == "" </span><span class="cov2" title="2">{
                result.AddError("is required", field)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
